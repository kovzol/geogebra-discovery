#!/usr/bin/env python
# -*- coding: utf-8 -*-

# This program adds extra entries in the ggbtrans database.
# These extra entries are not (yet) official properties and translations.
# Currently this program is used to maintain an extended translation database for GeoGebra Discovery,
# see https://github.com/kovzol/geogebra-discovery for details.
# Author: Zoltán Kovács <zoltan@geogebra.org>

# Usage:
# 1. Add entries in the main program (see below, at the end of this file). Don't delete existing entries, just add new ones.
# 2. Copy the raw ggbtransdb file from the current database to this folder.
# 3. Run this program.
# 4. Create an output folder, e.g. output-trunk, with "mkdir output-trunk".
# 5. Run "./export.py trunk output-trunk ggbtransdb".
# 6. Copy the contents of the output-trunk folder to fork/geogebra/common-jre/src/nonfree/resources/org/geogebra/common/jre/properties
#    in your local repository of GeoGebra Discovery.
# 7. Create another output folder, e.g. output-gwtjs, with "mkdir output-gwtjs".
# 8. Run "./export.py gwtjs output-gwtjs ggbtransdb".
# 9. Copy the contents of the output-trunk folder to fork/geogebra/web/src/nonfree/resources/org/geogebra/web/pub/js
#    in your local repository of GeoGebra Discovery.
# 10. Test the new translations.
# 11. Commit the changes in the fork/geogebra/ folder.

# We avoid overwriting or overlapping any existing or future entries, so we start our patching in a large ID area.
start_properties_translation_id = 1000000; # < 360000 on 2021-05-09
start_properties_property_id = 100000; # < 8000 on 2021-05-09

properties_translation_id = start_properties_translation_id
properties_property_id = start_properties_property_id

try:
    import sqlite3
except ImportError:
    import pysqlite2.dbapi2 as sqlite3

import shutil, time, optparse, os.path

def next_property_id():
    global properties_property_id
    properties_property_id += 1
    return properties_property_id

def add_property(properties_property_id, category_id, version, key):
    with sqlite3.connect("ggbtransdb") as conn:
        c = conn.cursor()
        query = "INSERT INTO properties_property (id, parent_id, category_id, version, comment, key, creation_date, modification_date, max_length, ticket) VALUES "
        query += "(" + str(properties_property_id) + ", NULL, " + str(category_id) + ", '" + str(version) + "', "
        query += "'created by a patch via patch.py', " + "'" + key + "', " + "DATE('now'), DATE('now'), NULL, NULL)"
        print(query)
        c.execute(query)

def add_translation(property_id, locale_id, text, author_id):
    with sqlite3.connect("ggbtransdb") as conn:
        c = conn.cursor()
        global properties_translation_id
        properties_translation_id += 1
        query = "INSERT INTO properties_translation (id, property_id, locale_id, text, comment, creation_date, modification_date, author_id) VALUES "
        query += "(" + str(properties_translation_id) + ", " + str(property_id) + ", " + str(locale_id) + ", " + "'" + text + "', "
        query += "'created by a patch via patch.py', DATE('now'), DATE('now'), " + str(author_id) + ")"
        print(query)
        c.execute(query)

def add_command(properties_property_id, key):
    add_property(properties_property_id, 2, 'stable', key)

def add_menu(properties_property_id, key):
    add_property(properties_property_id, 5, 'stable', key)

# Abbreviations
def m(properties_property_id, key):
    add_menu(properties_property_id, key)
def c(properties_property_id, key):
    add_command(properties_property_id, key)
def t(property_id, locale_id, text, author_id):
    add_translation(property_id, locale_id, text, author_id)
def n():
    return next_property_id()


def cleanup():
    with sqlite3.connect("ggbtransdb") as conn:
        c = conn.cursor()
        global start_properties_translation_id
        query = "DELETE from properties_translation WHERE id > " + str(start_properties_translation_id)
        print(query)
        c.execute(query)
        global start_properties_property_d
        query = "DELETE from properties_property WHERE id > " + str(start_properties_property_id)
        print(query)
        c.execute(query)

if __name__ == "__main__":
    # Delete eventually existing former extra entries:
    cleanup()

    # Create IDs for new properties.

    DISCOVER = n()
    DISCOVER_SYNTAX = n()
    DISCOVER_TOOL = n()
    DISCOVER_TOOL_HELP = n()
    DISCOVERED_THEOREMS_ON_POINT = n()
    NO_THEOREMS_FOUND = n()
    REDRAW_DIFFERENTLY = n()
    UNSUPPORTED_STEPS = n()
    IDENTICAL_POINTS_A = n()
    COLLINEAR_POINTS_A = n()
    CONCYCLIC_POINTS_A = n()
    SETS_OF_PARALLEL_AND_PERPENDICULAR_LINES_A = n()
    CONGRUENT_SEGMENTS_A = n()
    IN_PROGRESS = n()
    CANNOT_DECIDE_EQUALITY_OF_POINTS_A_B = n()

    COMPARE = n()
    COMPARE_SYNTAX = n()
    COMPARE_A_AND_B = n()

    INCIRCLECENTER = n()
    INCIRCLECENTER_SYNTAX = n()
    INCIRCLECENTER_TOOL = n()
    INCIRCLECENTER_TOOL_HELP = n()

    INCIRCLE_TOOL = n()
    INCIRCLE_TOOL_HELP = n()

    LOCUSEQUATION_TOOL = n()
    LOCUSEQUATION_TOOL_HELP = n()

    ENVELOPE_TOOL = n()
    ENVELOPE_TOOL_HELP = n()

    SHOWPROOF = n()
    SHOWPROOF_SYNTAX = n()
    PROVE_THAT_A = n()
    LET_A_BE_ARBITRARY_POINTS = n()
    LET_A_BE_THE_B = n()
    LET_A_BE_A_B = n()
    LET_A_BE_THE_REGULAR_POLYGON_BCD = n()
    LET_A_BE_THE_REGULAR_BGON_VERTICES_C = n()
    DENOTE_THE_EXPRESSION_A_BY_B = n()
    PROOF_UNKNOWN = n()
    STATEMENT_ALWAYS_TRUE = n()
    TRUE_ON_PARTS = n()
    TRUE_UNDER_NONDEGENERACY_CONDITIONS = n()
    STATEMENT_FALSE = n()
    STATEMENT_TRIVIAL = n()
    PROVE_BY_CONTRADICTION = n()
    NO_FULL_PROOF = n()
    NO_FULL_PRESENTATION = n()
    TRY_NEWER_VERSION = n()
    UNSUPPORTED_AXES_FIXED_SLOPE_LINES = n()
    CONSIDERING_DEFINITION_A = n()
    LET_FREE_POINT_A_DENOTED_BY_B = n()
    ONLY_FIRST_FIXED_BECAUSE_A_ON_B = n()
    ONLY_FIRST_FIXED_EXPRESSION = n()
    LET_DEPENDENT_POINT_A_DENOTED_BY_B = n()
    OBJECT_A_INTRODUCES = n()
    COMMAND_A_NOT_FULLY_IMPLEMENTED = n()
    COMMAND_A_NOT_IMPLEMENTED = n()
    THESIS_EQS_NON_DENIED = n()
    THESIS_EQ_DENIED = n()
    DUMMY_VAR_NEG = n()
    STATEMENT_A_NOT_FULLY_IMPLEMENTED = n()
    STATEMENT_A_NOT_IMPLEMENTED = n()
    WLOG_COORDINATES = n()
    CANNOT_DECIDE_ALGEBRAIC_DIFFICULTIES = n()
    STATEMENT_ALGEBRAICALLY_TRUE_GEOMETRICALLY_AMBIGUOUS = n()
    STATEMENT_TRUE_NDG = n()
    AFTER_SUBS = n()
    STATEMENT_TRUE_NDG_UNREADABLE = n()
    ALL_HYPOS_NEG_THESIS = n()
    NOW_CONSIDER = n()
    CONTRADICTION_THIS_PROVES = n()
    DIFFICULTY_A = n()
    PROOF_PREPARATION_SEEMS_DIFFICULT = n()
    FORCING_NON_COLLINEARITY = n()

    REALQUANTIFIERELIMINATION = n()
    REALQUANTIFIERELIMINATION_SYNTAX = n()

    STEPWISEDISCOVERY = n()
    STEPWISEDISCOVERY_SYNTAX = n()
    STEPWISEDISCOVERY_INFORMATION = n()
    STEPWISEDISCOVERY_ENABLED = n()
    STEPWISEDISCOVERY_DISABLED = n()
    STEPWISEDISCOVERY_STYLEBAR = n()

    EXPORT_AS_LATEX = n()

    PLOT2D = n()
    PLOT2D_SYNTAX = n()

    A_VALUE_OF_CENTER_OF_B = n()
    A_VALUE_OF_A_POINT_OF_B = n()
    A_VALUE_OF_AN_IMPLICITLY_INTRODUCED_FOOT_POINT_FOR_ORTHOGONAL_LINE_AT_B_TO_C = n()
    A_VALUE_OF_MIDPOINT_OF_B = n()
    A_VALUE_OF_ROTATION_OF_POINT_B_AROUND_THE_MIDPOINT_OF_C_BY_D_DEGREES = n()

    # Languages
    EN = 1
    DE = 6
    ES = 9
    HU = 16

    # Authors
    ZK = 34 # Zoltán Kovács
    TR = 34 # Tomás Recio

    # Properties
    c(DISCOVER, 'Discover')
    c(DISCOVER_SYNTAX, 'Discover.Syntax')
    m(DISCOVER_TOOL, 'Discover')
    m(DISCOVER_TOOL_HELP, 'Discover.Help')
    m(DISCOVERED_THEOREMS_ON_POINT, 'DiscoveredTheoremsOnPointA')
    m(NO_THEOREMS_FOUND, 'NoTheoremsFound')
    m(REDRAW_DIFFERENTLY, 'RedrawDifferently')
    m(UNSUPPORTED_STEPS, 'UnsupportedSteps')
    m(CONCYCLIC_POINTS_A, 'ConcyclicPointsA')
    m(IDENTICAL_POINTS_A, 'IdenticalPointsA')
    m(COLLINEAR_POINTS_A, 'CollinearPointsA')
    m(CONGRUENT_SEGMENTS_A, 'CongruentSegmentsA')
    m(SETS_OF_PARALLEL_AND_PERPENDICULAR_LINES_A, 'SetsOfParallelAndPerpendicularLinesA')
    m(IN_PROGRESS, 'InProgress')
    m(CANNOT_DECIDE_EQUALITY_OF_POINTS_A_B, 'CannotDecideEqualityofPointsAB')
    t(DISCOVER, EN, 'Discover', ZK)
    t(DISCOVER, DE, 'Entdecken', ZK)
    t(DISCOVER, ES, 'Descubrir', ZK)
    t(DISCOVER, HU, 'Felfedezés', ZK)
    t(DISCOVER_TOOL, EN, 'Discover', ZK)
    t(DISCOVER_TOOL, DE, 'Entdecken', ZK)
    t(DISCOVER_TOOL, ES, 'Descubrir', ZK)
    t(DISCOVER_TOOL, HU, 'Felfedezés', ZK)
    t(DISCOVER_TOOL_HELP, EN, 'Select one point', ZK)
    t(DISCOVER_TOOL_HELP, HU, 'Egy pont kijelölése', ZK)
    t(DISCOVER_TOOL_HELP, DE, 'Gib einen Punkt an', ZK)
    t(DISCOVER_TOOL_HELP, ES, 'Selecciona punto', ZK)
    t(DISCOVERED_THEOREMS_ON_POINT, EN, 'Discovered theorems on point %0', ZK)
    t(DISCOVERED_THEOREMS_ON_POINT, DE, 'Entdeckungen über den Punkt %0', ZK)
    t(DISCOVERED_THEOREMS_ON_POINT, ES, 'Teoremas descubiertos con el punto %0', ZK)
    t(DISCOVERED_THEOREMS_ON_POINT, HU, 'A(z) %0 ponttal kapcsolatos felfedezések', ZK)
    t(DISCOVER_SYNTAX, EN, '[ <Point> ]', ZK)
    t(DISCOVER_SYNTAX, DE, '[ <Punkt> ]', ZK)
    t(DISCOVER_SYNTAX, HU, '[ <Pont> ]', ZK)
    t(DISCOVER_SYNTAX, ES, '[ <Punto> ]', ZK)
    t(NO_THEOREMS_FOUND, EN, 'No theorems were found.', ZK)
    t(NO_THEOREMS_FOUND, DE, 'Keine Sätze wurden gefunden.', ZK)
    t(NO_THEOREMS_FOUND, HU, 'Nincs semmi figyelemreméltó.', ZK)
    t(NO_THEOREMS_FOUND, ES, 'No se encontraron teoremas descubiertos.', ZK)
    t(REDRAW_DIFFERENTLY, EN, 'Try to redraw the construction differently.', ZK)
    t(REDRAW_DIFFERENTLY, DE, 'Versuchen Sie, die Konstruktion anders zu zeichnen.', ZK)
    t(REDRAW_DIFFERENTLY, HU, 'Próbálja újrarajzolni az ábrát másképpen!', ZK)
    t(REDRAW_DIFFERENTLY, ES, 'Intente volver a dibujar la figura de forma diferente.', ZK)
    t(UNSUPPORTED_STEPS, EN, 'The construction contains unsupported steps.', ZK)
    t(UNSUPPORTED_STEPS, ES, 'La figura consta de pasos no compatibles.', ZK)
    t(UNSUPPORTED_STEPS, DE, 'Die Konstruktion enthält Schritte, die nicht unterstützt sind.', ZK)
    t(UNSUPPORTED_STEPS, HU, 'Nem támogatott lépéseket tartalmaz a szerkesztés.', ZK)
    t(IDENTICAL_POINTS_A, EN, 'Identical points: %0', ZK)
    t(IDENTICAL_POINTS_A, DE, 'Identische Punkte: %0', ZK)
    t(IDENTICAL_POINTS_A, ES, 'Puntos idénticos: %0', ZK)
    t(IDENTICAL_POINTS_A, HU, 'Megegyező pontok: %0', ZK)
    t(COLLINEAR_POINTS_A, EN, 'Collinear points: %0', ZK)
    t(COLLINEAR_POINTS_A, DE, 'Kollineare Punkte: %0', ZK)
    t(COLLINEAR_POINTS_A, ES, 'Puntos colineales: %0', ZK)
    t(COLLINEAR_POINTS_A, HU, 'Kollineáris pontok: %0', ZK)
    t(CONCYCLIC_POINTS_A, EN, 'Concyclic points: %0', ZK)
    t(CONCYCLIC_POINTS_A, DE, 'Konzyklische Punkte: %0', ZK)
    t(CONCYCLIC_POINTS_A, ES, 'Puntos concíclicos: %0', ZK)
    t(CONCYCLIC_POINTS_A, HU, 'Egy körre illeszkedő pontok: %0', ZK)
    t(CONGRUENT_SEGMENTS_A, EN, 'Congruent segments: %0', ZK)
    t(CONGRUENT_SEGMENTS_A, DE, 'Kongruente Strecken: %0', ZK)
    t(CONGRUENT_SEGMENTS_A, ES, 'Segmentos congruentes: %0', ZK)
    t(CONGRUENT_SEGMENTS_A, HU, 'Egybevágó szakaszok: %0', ZK)
    t(SETS_OF_PARALLEL_AND_PERPENDICULAR_LINES_A, EN, 'Sets of parallel and perpendicular lines: %0', ZK)
    t(SETS_OF_PARALLEL_AND_PERPENDICULAR_LINES_A, DE, 'Mengen von parallelen und senkrechten Geraden: %0', ZK)
    t(SETS_OF_PARALLEL_AND_PERPENDICULAR_LINES_A, ES, 'Líneas paralelas y perpendiculares: %0', ZK)
    t(SETS_OF_PARALLEL_AND_PERPENDICULAR_LINES_A, HU, 'Párhuzamos és merőleges egyenesek: %0', ZK)
    t(IN_PROGRESS, EN, 'In progress', ZK)
    t(IN_PROGRESS, DE, 'In Bearbeitung', ZK)
    t(IN_PROGRESS, ES, 'En curso', ZK)
    t(IN_PROGRESS, HU, 'Folyamatban', ZK)
    t(CANNOT_DECIDE_EQUALITY_OF_POINTS_A_B, EN, 'Cannot decide equality of points %0 and %1.', ZK)
    t(CANNOT_DECIDE_EQUALITY_OF_POINTS_A_B, DE, 'Kann die Gleichheit der Punkte %0 und %1 nicht entscheiden.', ZK)
    t(CANNOT_DECIDE_EQUALITY_OF_POINTS_A_B, ES, 'No se puede decidir la igualdad de los puntos %0 y %1.', ZK)
    t(CANNOT_DECIDE_EQUALITY_OF_POINTS_A_B, HU, 'Nem tudom eldönteni, hogy a(z) %0 és %1 pontok megegyeznek-e.', ZK)

    c(COMPARE, 'Compare')
    c(COMPARE_SYNTAX, 'Compare.Syntax')
    m(COMPARE_A_AND_B, 'CompareAandB')
    t(COMPARE, EN, 'Compare', ZK)
    t(COMPARE, DE, 'Vergleiche', ZK)
    t(COMPARE, ES, 'Compara', ZK)
    t(COMPARE, HU, 'Összehasonlít', ZK)
    t(COMPARE_SYNTAX, EN, '[ <Expression>, <Expression> ]', ZK)
    t(COMPARE_SYNTAX, ES, '[ <Expresión>, <Expresión> ]', ZK)
    t(COMPARE_SYNTAX, DE, '[ <Ausdruck>, <Ausdruck> ]', ZK)
    t(COMPARE_SYNTAX, HU, '[ <Kifejezés>, <Kifejezés> ]', ZK)
    t(COMPARE_A_AND_B, EN, 'Compare %0 and %1.', ZK)

    c(INCIRCLECENTER, 'IncircleCenter')
    c(INCIRCLECENTER_SYNTAX, 'IncircleCenter.Syntax')
    m(INCIRCLECENTER_TOOL, 'IncircleCenter')
    m(INCIRCLECENTER_TOOL_HELP, 'IncircleCenter.Help')
    t(INCIRCLECENTER, EN, 'IncircleCenter', ZK)
    t(INCIRCLECENTER, HU, 'BeírtKörKözéppontja', ZK)
    t(INCIRCLECENTER, DE, 'Inkreismittelpunkt', ZK)
    t(INCIRCLECENTER, ES, 'CentroCircunferenciaInscrita', ZK)
    t(INCIRCLECENTER_SYNTAX, EN, '[ <Point>, <Point>, <Point> ]', ZK)
    t(INCIRCLECENTER_SYNTAX, HU, '[ <Pont>, <Pont>, <Pont> ]', ZK)
    t(INCIRCLECENTER_SYNTAX, DE, '[ <Punkt>, <Punkt>, <Punkt> ]', ZK)
    t(INCIRCLECENTER_SYNTAX, ES, '[ <Punto>, <Punto>, <Punto> ]', ZK)
    t(INCIRCLECENTER_TOOL, ES, 'Centro de la circunferencia inscrita', ZK)
    t(INCIRCLECENTER_TOOL, EN, 'Incircle Center', ZK)
    t(INCIRCLECENTER_TOOL, DE, 'Inkreismittelpunkt', ZK)
    t(INCIRCLECENTER_TOOL, HU, 'Beírt kör középpontja', ZK)
    t(INCIRCLECENTER_TOOL_HELP, EN, 'Select three points', ZK)
    t(INCIRCLECENTER_TOOL_HELP, ES, 'Selecciona tres puntos', ZK)
    t(INCIRCLECENTER_TOOL_HELP, DE, 'Gib drei Punkte an', ZK)
    t(INCIRCLECENTER_TOOL_HELP, HU, 'Három pont kijelölése', ZK)

    m(INCIRCLE_TOOL, 'Incircle')
    m(INCIRCLE_TOOL_HELP, 'Incircle.Help')
    t(INCIRCLE_TOOL, EN, 'Incircle', ZK)
    t(INCIRCLE_TOOL, DE, 'Inkreis', ZK)
    t(INCIRCLE_TOOL, ES, 'Circunferencia inscrita', ZK)
    t(INCIRCLE_TOOL, HU, 'Beírt kör', ZK)
    t(INCIRCLE_TOOL_HELP, HU, 'Három pont kijelölése', ZK)
    t(INCIRCLE_TOOL_HELP, ES, 'Selecciona tres puntos', ZK)
    t(INCIRCLE_TOOL_HELP, DE, 'Gib drei Punkte an', ZK)
    t(INCIRCLE_TOOL_HELP, EN, 'Select three points', ZK)

    m(LOCUSEQUATION_TOOL, 'LocusEquation.Tool')
    m(LOCUSEQUATION_TOOL_HELP, 'LocusEquation.Help')
    t(LOCUSEQUATION_TOOL, ES, 'Ecuación Lugar Geométrico', ZK)
    t(LOCUSEQUATION_TOOL, DE, 'Ortsliniengleichung', ZK)
    t(LOCUSEQUATION_TOOL, EN, 'Locus Equation', ZK)
    t(LOCUSEQUATION_TOOL, HU, 'Mértani hely egyenlete', ZK)
    t(LOCUSEQUATION_TOOL_HELP, EN, 'Select locus point, then point on object', ZK)
    t(LOCUSEQUATION_TOOL_HELP, DE, 'Wähle einen Punkt zum Erzeugen der Ortslinie, dann einen Punkt auf einem Objekt', ZK)
    t(LOCUSEQUATION_TOOL_HELP, ES, 'Punto del lugar geométrico; luego, punto en objeto', ZK)
    t(LOCUSEQUATION_TOOL_HELP, HU, 'Mértani hely pontja, majd pont az objektumon', ZK)

    m(ENVELOPE_TOOL, 'Envelope.Tool')
    m(ENVELOPE_TOOL_HELP, 'Envelope.Help')
    t(ENVELOPE_TOOL, EN, 'Envelope', ZK)
    t(ENVELOPE_TOOL, DE, 'Einhüllende', ZK)
    t(ENVELOPE_TOOL, ES, 'Envolvente', ZK)
    t(ENVELOPE_TOOL, HU, 'Burkoló', ZK)
    t(ENVELOPE_TOOL_HELP, EN, 'Select path, then point on object', ZK)
    t(ENVELOPE_TOOL_HELP, DE, 'Gib eine Kurve an, dann einen Punkt auf einem Pfad', ZK)
    t(ENVELOPE_TOOL_HELP, ES, 'Trayecto del envolvente; luego, punto en objeto', ZK)
    t(ENVELOPE_TOOL_HELP, HU, 'Görbe, amelynek burkolóját keressük, majd egy alakzaton mozgó pont', ZK)

    c(SHOWPROOF, 'ShowProof')
    c(SHOWPROOF_SYNTAX, 'ShowProof.Syntax')
    m(PROVE_THAT_A, 'ProveThatA')
    m(LET_A_BE_ARBITRARY_POINTS, 'LetABeArbitraryPoints')
    m(LET_A_BE_THE_B, 'LetABeTheB')
    m(LET_A_BE_A_B, 'LetABeAB')
    m(LET_A_BE_THE_REGULAR_POLYGON_BCD, 'LetABeTheRegularPolygonBCD')
    m(LET_A_BE_THE_REGULAR_BGON_VERTICES_C, 'LetABeTheRegularBGonVerticesC')
    m(DENOTE_THE_EXPRESSION_A_BY_B, 'DenoteTheExpressionAByB')
    m(PROOF_UNKNOWN, 'ProofUnknown')
    m(STATEMENT_ALWAYS_TRUE, 'StatementAlwaysTrue')
    m(TRUE_ON_PARTS, 'TrueOnParts')
    m(TRUE_UNDER_NONDEGENERACY_CONDITIONS, 'TrueUnderNondegeneracyConditions')
    m(STATEMENT_FALSE, 'StatementFalse')
    m(STATEMENT_TRIVIAL, 'StatementTrivial')
    m(PROVE_BY_CONTRADICTION, 'ProveByContradiction')
    m(NO_FULL_PROOF, 'NoFullProof')
    m(NO_FULL_PRESENTATION, 'NoFullPresentation')
    m(TRY_NEWER_VERSION, 'TryNewerVersion')
    m(UNSUPPORTED_AXES_FIXED_SLOPE_LINES, 'AxesFixedSlopeLinesUnsupportedSteps')
    m(CONSIDERING_DEFINITION_A, 'ConsideringDefinitionA')
    m(LET_FREE_POINT_A_DENOTED_BY_B, 'LetFreePointADenotedByB')
    m(ONLY_FIRST_FIXED_BECAUSE_A_ON_B, 'OnlyFirstFixedBecauseAOnB')
    m(ONLY_FIRST_FIXED_EXPRESSION, 'OnlyFirstFixedExpression')
    m(LET_DEPENDENT_POINT_A_DENOTED_BY_B, 'LetDependentPointADenotedByB')
    m(OBJECT_A_INTRODUCES, 'ObjectAIntroduces')
    m(COMMAND_A_NOT_FULLY_IMPLEMENTED, 'CommandANotFullyImplemented')
    m(COMMAND_A_NOT_IMPLEMENTED, 'CommandANotImplemented')
    m(THESIS_EQS_NON_DENIED, 'ThesisEqsNonDenied')
    m(THESIS_EQ_DENIED, 'ThesisEqDenied')
    m(DUMMY_VAR_NEG, 'DummyVarNeg')
    m(STATEMENT_A_NOT_FULLY_IMPLEMENTED, 'StatementANotFullyImplemented')
    m(STATEMENT_A_NOT_IMPLEMENTED, 'StatementANotImplemented')
    m(WLOG_COORDINATES, 'WlogCoordinates')
    m(CANNOT_DECIDE_ALGEBRAIC_DIFFICULTIES, 'CannotDecideAlgebraicDifficulties')
    m(STATEMENT_ALGEBRAICALLY_TRUE_GEOMETRICALLY_AMBIGUOUS, 'StatementAlgebraicallyTrueGeometricallyAmbiguous')
    m(STATEMENT_TRUE_NDG, 'StatementTrueNdg')
    m(AFTER_SUBS, 'AfterSubs')
    m(STATEMENT_TRUE_NDG_UNREADABLE, 'StatementTrueNdgUnreadable')
    m(ALL_HYPOS_NEG_THESIS, 'AllHyposNegThesis')
    m(NOW_CONSIDER, 'NowConsider')
    m(CONTRADICTION_THIS_PROVES, 'ContradictionThisProves')
    m(DIFFICULTY_A, 'DifficultyA')
    m(PROOF_PREPARATION_SEEMS_DIFFICULT, 'ProofPreparationSeemsDifficult')
    m(FORCING_NON_COLLINEARITY, 'ForcingNonCollinearity')
    m(A_VALUE_OF_CENTER_OF_B, 'AValueOfCenterOfB')
    m(A_VALUE_OF_A_POINT_OF_B, 'AValueOfAPointOfB')
    m(A_VALUE_OF_AN_IMPLICITLY_INTRODUCED_FOOT_POINT_FOR_ORTHOGONAL_LINE_AT_B_TO_C, 'AValueOfAnImplicitlyIntroducedFootPointForOrthogonalLineAtBToC')
    m(A_VALUE_OF_MIDPOINT_OF_B, 'AValueOfMidpointOfB')
    m(A_VALUE_OF_ROTATION_OF_POINT_B_AROUND_THE_MIDPOINT_OF_C_BY_D_DEGREES, 'AValueOfRotationOfPointBAroundTheMidpointOfCByDDegrees')
    #
    t(SHOWPROOF, EN, 'ShowProof', ZK)
    t(SHOWPROOF, HU, 'BizonyításLépései', ZK)
    t(SHOWPROOF, DE, 'BeweisSchritte', ZK)
    t(SHOWPROOF_SYNTAX, EN, '[ <Boolean Expression> ]', ZK)
    t(SHOWPROOF_SYNTAX, HU, '[ <Logikai kifejezés> ]', ZK)
    t(SHOWPROOF_SYNTAX, DE, '[ <Boolscher Ausdruck> ]', ZK)
    t(PROVE_THAT_A, EN, 'Prove that %0.', ZK)
    t(PROVE_THAT_A, HU, 'Bízonyítsuk be, hogy %0.', ZK)
    t(PROVE_THAT_A, DE, 'Beweise Folgendes: %0.', ZK)
    t(LET_A_BE_ARBITRARY_POINTS, EN, 'Let %0 be arbitrary points.', ZK)
    t(LET_A_BE_ARBITRARY_POINTS, HU, 'Legyenek %0 tetszőleges pontok.', ZK)
    t(LET_A_BE_ARBITRARY_POINTS, DE, 'Seien %0 beliebige Punkte.', ZK)
    t(LET_A_BE_THE_B, EN, 'Let %0 be the %1.', ZK)
    t(LET_A_BE_THE_B, HU, 'Legyen %0 a(z) %1.', ZK)
    t(LET_A_BE_THE_B, DE, 'Sei %0: %1.', ZK)
    t(LET_A_BE_A_B, EN, 'Let %0 be a %1.', ZK)
    t(LET_A_BE_A_B, HU, 'Legyen %0 %1.', ZK)
    t(LET_A_BE_A_B, DE, 'Sei %0 %1.', ZK)
    t(LET_A_BE_THE_REGULAR_POLYGON_BCD, EN, 'Let %0 be the regular %3-gon over the segment %1, %2.', ZK)
    t(LET_A_BE_THE_REGULAR_POLYGON_BCD, HU, 'Legyen %0 a(z) %1, %2 szakasz fölé írt szabályos %3-szög.', ZK)
    t(LET_A_BE_THE_REGULAR_POLYGON_BCD, DE, 'Sei %0 das regelmäßige $3-Eck über der Strecke %1, %2.', ZK)
    t(LET_A_BE_THE_REGULAR_BGON_VERTICES_C, EN, 'Let %0 be the regular %1-gon with vertices %2.', ZK)
    t(LET_A_BE_THE_REGULAR_BGON_VERTICES_C, HU, 'Legyen %0 szabályos %1-szög a(z) %2 csúcsokkal.', ZK)
    t(LET_A_BE_THE_REGULAR_BGON_VERTICES_C, DE, 'Legyen %0 das regelmäßige %1-Eck mit Eckpunkten %2.', ZK)
    t(DENOTE_THE_EXPRESSION_A_BY_B, EN, 'Denote the expression %0 by %1.', ZK)
    t(DENOTE_THE_EXPRESSION_A_BY_B, HU, 'Jelölje %1 a(z) %0 kifejezést.', ZK)
    t(DENOTE_THE_EXPRESSION_A_BY_B, DE, 'Sei der Ausdruck %0 beschriftet mit %1.', ZK)
    t(PROOF_UNKNOWN, EN, 'The statement could not be proven nor disproven.', ZK)
    t(PROOF_UNKNOWN, HU, 'Az állítást sem bizonyítani, sem cáfolni nem sikerült.', ZK)
    t(PROOF_UNKNOWN, DE, 'Die Aussage wurde weder bewiesen noch widerlegt können.', ZK)
    t(STATEMENT_ALWAYS_TRUE, EN, 'The statement is always true.', ZK)
    t(STATEMENT_ALWAYS_TRUE, HU, 'Az állítás mindig igaz.', ZK)
    t(STATEMENT_ALWAYS_TRUE, DE, 'Die Aussage ist immer wahr.', ZK)
    t(TRUE_ON_PARTS, EN, 'The statement is true on parts, false on parts.', ZK)
    t(TRUE_ON_PARTS, HU, 'Az állítás részben igaz, részben hamis.', ZK)
    t(TRUE_ON_PARTS, DE, 'Die Aussage ist teilweise wahr und teilweise falsch.', ZK)
    t(TRUE_UNDER_NONDEGENERACY_CONDITIONS, EN, 'The statement is true under some non-degeneracy conditions (see below).', ZK)
    t(TRUE_UNDER_NONDEGENERACY_CONDITIONS, HU, 'Az állítás igaz, ha a szerkesztés nem elfajuló (lásd lejjebb).', ZK)
    t(TRUE_UNDER_NONDEGENERACY_CONDITIONS, DE, 'Die Aussage ist wahr, falls die Konstruktion nicht entartet ist (siehe unten).', ZK)
    t(STATEMENT_FALSE, EN, 'The statement is false.', ZK)
    t(STATEMENT_FALSE, HU, 'Az állítás hamis.', ZK)
    t(STATEMENT_FALSE, DE, 'Die Aussage ist falsch.', ZK)
    t(STATEMENT_TRIVIAL, EN, 'The statement is trivial.', ZK)
    t(STATEMENT_TRIVIAL, HU, 'Az állítás triviális.', ZK)
    t(STATEMENT_TRIVIAL, DE, 'Die Aussage ist trivial.', ZK)
    t(PROVE_BY_CONTRADICTION, EN, 'We prove this by contradiction.', ZK)
    t(PROVE_BY_CONTRADICTION, HU, 'Indirekt bizonyítást adunk.', ZK)
    t(PROVE_BY_CONTRADICTION, DE, 'Ein Indirektbeweis wird gezeigt.', ZK)
    t(NO_FULL_PROOF, EN, 'Currently no full proof can be provided, but just some steps.', ZK)
    t(NO_FULL_PROOF, HU, 'Jelenleg nem áll rendelkezésre teljes bizonyítás, csak néhány lépés.', ZK)
    t(NO_FULL_PROOF, DE, 'Momentan steht kein vollständiger Beweis zur Verfügung, nur manche Schritte.', ZK)
    t(NO_FULL_PRESENTATION, EN, 'In the background, all steps are checked, but a full presentation is not yet implemented.', ZK)
    t(NO_FULL_PRESENTATION, HU, 'A háttérben minden lépés ellenőrzésre került, de ezek ismertetése még nincs leprogramozva.', ZK)
    t(NO_FULL_PRESENTATION, DE, 'Im Hintergrund wurden alle Schritte überprüft, eine vollständige Präsentation ist aber nicht implementiert.', ZK)
    t(TRY_NEWER_VERSION, EN, 'Please try a newer version of GeoGebra Discovery if possible.', ZK)
    t(TRY_NEWER_VERSION, HU, 'Lehet, hogy a program egy újabb verziójában ez a funkció már rendelkezésre áll.', ZK)
    t(TRY_NEWER_VERSION, DE, 'Versuchen Sie eine neuere Version von GeoGebra Discovery zu verwenden, falls möglich.', ZK)
    t(UNSUPPORTED_AXES_FIXED_SLOPE_LINES, EN, 'Statements containing axes or fixed slope lines are unsupported.', ZK)
    t(UNSUPPORTED_AXES_FIXED_SLOPE_LINES, HU, 'Tengelyeket és rögzített meredekségű egyeneseket tartalmazó állítások nem támogatottak.', ZK)
    t(UNSUPPORTED_AXES_FIXED_SLOPE_LINES, DE, 'Aussagen über Achsen oder Geraden mit fixierten Steigung sind nicht unterstützt.', ZK)
    t(CONSIDERING_DEFINITION_A, EN, 'Considering definition %0:', ZK)
    t(CONSIDERING_DEFINITION_A, HU, 'A(z) %0 definíciót figyelembe véve:', ZK)
    t(CONSIDERING_DEFINITION_A, DE, 'Laut Definition %0:', ZK)
    t(LET_FREE_POINT_A_DENOTED_BY_B, EN, 'Let free point %0 be denoted by %1.', ZK)
    t(LET_FREE_POINT_A_DENOTED_BY_B, HU, 'Jelöljük a(z) %0 szabad pontot %1-val/-vel.', ZK)
    t(LET_FREE_POINT_A_DENOTED_BY_B, DE, 'Sei freier Punkt %0 mit %1 beschriftet.', ZK)
    t(ONLY_FIRST_FIXED_BECAUSE_A_ON_B, EN, 'Only the first free point can be fixed, because %0 is on linear path %1.', ZK)
    t(ONLY_FIRST_FIXED_BECAUSE_A_ON_B, HU, 'Csak az első pont rögzíthető, mert %0 a(z) %1 egyenesen van.', ZK)
    t(ONLY_FIRST_FIXED_BECAUSE_A_ON_B, DE, 'Nur der erste Punkt kann fixiert werden, weil %0 auf der Geraden %1 liegt.', ZK)
    t(LET_DEPENDENT_POINT_A_DENOTED_BY_B, EN, 'Let dependent point %0 be denoted by %1.', ZK)
    t(LET_DEPENDENT_POINT_A_DENOTED_BY_B, HU, 'Jelöljük a(z) %0 függő pontot %1-val/-vel.', ZK)
    t(LET_DEPENDENT_POINT_A_DENOTED_BY_B, DE, 'Beschriften wir den abhängigen Punkt %0 mit %1.', ZK)
    t(OBJECT_A_INTRODUCES, EN, 'Object %0 introduces the following extra variables:', ZK)
    t(OBJECT_A_INTRODUCES, HU, 'A(z) %0 objektumhoz a következő további változókra lesz szükség:', ZK)
    t(OBJECT_A_INTRODUCES, DE, 'Fürs Objekt %0 sind folgende Variablen notwendig:', ZK)
    t(COMMAND_A_NOT_FULLY_IMPLEMENTED, EN, 'Command %0 is not fully implemented in the prover.', ZK)
    t(COMMAND_A_NOT_FULLY_IMPLEMENTED, HU, 'A(z) %0 parancs nem áll teljesen rendelkezésre a bizonyító alrendszerben.', ZK)
    t(COMMAND_A_NOT_FULLY_IMPLEMENTED, DE, 'Befehl %0 ist nicht vollständig unterstützt.', ZK)
    t(COMMAND_A_NOT_IMPLEMENTED, EN, 'Command %0 is not implemented in the prover.', ZK)
    t(COMMAND_A_NOT_IMPLEMENTED, HU, 'A(z) %0 parancs nem áll rendelkezésre a bizonyító alrendszerben.', ZK)
    t(COMMAND_A_NOT_IMPLEMENTED, DE, 'Befehl %0 ist nicht unterstützt.', ZK)
    t(THESIS_EQS_NON_DENIED, EN, 'Thesis equations (non-denied ones):', ZK)
    t(THESIS_EQS_NON_DENIED, HU, 'A következmény egyenletei (az állító formájúak):', ZK)
    t(THESIS_EQS_NON_DENIED, DE, 'Die Gleichungen der Konsequenz (die nicht negiert sind):', ZK)
    t(THESIS_EQ_DENIED, EN, 'Thesis reductio ad absurdum (denied statement):', ZK)
    t(THESIS_EQ_DENIED, HU, 'A következmény tagadása:', ZK)
    t(THESIS_EQ_DENIED, DE, 'Die Verneinung der Konsequenz:', ZK)
    t(DUMMY_VAR_NEG, EN, 'dummy variable to express negation', ZK)
    t(DUMMY_VAR_NEG, HU, 'extra változó a tagadáshoz', ZK)
    t(DUMMY_VAR_NEG, DE, 'extra Variable für die Verneinung', ZK)
    t(STATEMENT_A_NOT_FULLY_IMPLEMENTED, EN, 'Statement %0 is not fully implemented in the prover.', ZK)
    t(STATEMENT_A_NOT_FULLY_IMPLEMENTED, HU, 'A(z) %0 állítás nem áll teljesen rendelkezésre a bizonyító alrendszerben.', ZK)
    t(STATEMENT_A_NOT_IMPLEMENTED, EN, 'Statement %0 is not implemented in the prover.', ZK)
    t(STATEMENT_A_NOT_IMPLEMENTED, HU, 'A(z) %0 állítás nem áll rendelkezésre a bizonyító alrendszerben.', ZK)
    t(STATEMENT_A_NOT_IMPLEMENTED, DE, 'Aussage %0 ist nicht vollständig unterstützt.', ZK)
    t(WLOG_COORDINATES, EN, 'Without loss of generality, some coordinates can be fixed:', ZK)
    t(WLOG_COORDINATES, HU, 'Az általánosság megszorítása nélkül néhány koordináta rögzíthető:', ZK)
    t(WLOG_COORDINATES, DE, 'Ohne Beschränkung der Allgemeinheit können manche Koordinaten fixiert werden:', ZK)
    t(CANNOT_DECIDE_ALGEBRAIC_DIFFICULTIES, EN, 'Sorry, the program cannot decide due to algebraic difficulties.', ZK)
    t(CANNOT_DECIDE_ALGEBRAIC_DIFFICULTIES, HU, 'Sajnos, algebrai okok miatt a program képtelen eldönteni.', ZK)
    t(CANNOT_DECIDE_ALGEBRAIC_DIFFICULTIES, DE, 'Leider kann das Programm aus algebraischen Gründen keine Entscheidung treffen.', ZK)
    t(STATEMENT_ALGEBRAICALLY_TRUE_GEOMETRICALLY_AMBIGUOUS, EN, 'The statement is algebraically true, but geometrically ambiguous.', ZK)
    t(STATEMENT_ALGEBRAICALLY_TRUE_GEOMETRICALLY_AMBIGUOUS, HU, 'Az állítás algebrailag helyes, de geometriai értelemben nem feltétlenül.', ZK)
    t(STATEMENT_ALGEBRAICALLY_TRUE_GEOMETRICALLY_AMBIGUOUS, DE, 'Die Aussage ist algebraisch richtig, aber im geometrischen Sinne nicht unbedingt.', ZK)
    t(STATEMENT_TRUE_NDG, EN, 'The statement can be suspected to be true under some non-degeneracy conditions:', ZK)
    t(STATEMENT_TRUE_NDG, HU, 'Az állítás a következő nem-elfajuló feltételek esetén lesz igaz:', ZK)
    t(STATEMENT_TRUE_NDG, DE, 'Die Aussage ist wahr unter folgenden nicht-entarteten Bedingungen:', ZK)
    t(AFTER_SUBS, EN, 'After substitutions:', ZK)
    t(AFTER_SUBS, HU, 'Behelyettesítés után:', ZK)
    t(AFTER_SUBS, DE, 'Nach Einsetzen:', ZK)
    t(STATEMENT_TRUE_NDG_UNREADABLE, EN, 'The statement is true under some non-degeneracy conditions (they cannot be expressed in simple geometric terms):', ZK)
    t(STATEMENT_TRUE_NDG_UNREADABLE, HU, 'Az állítás bizonyos nem-elfajuló feltételek esetén lesz igaz (melyek nem adhatók meg egyszerű geometriai formában):', ZK)
    t(STATEMENT_TRUE_NDG_UNREADABLE, DE, 'Die Aussage ist wahr unter bestimmten nicht-entarteten Bedingungen (die in keiner einfachen Form ausgedrückt werden können):', ZK)
    t(ALL_HYPOS_NEG_THESIS, EN, 'All hypotheses and the negated thesis after substitutions:', ZK)
    t(ALL_HYPOS_NEG_THESIS, HU, 'Az előfeltételek és tagadott következmény behelyettesítés után:', ZK)
    t(ALL_HYPOS_NEG_THESIS, DE, 'Alle Bedingungen und die negierte Konsequenz nach Einsetzen:', ZK)
    t(NOW_CONSIDER, EN, 'Now we consider the following expression:', ZK)
    t(NOW_CONSIDER, HU, 'Most tekintsük a következő kifejezést:', ZK)
    t(NOW_CONSIDER, DE, 'Nun betrachten wir folgenden Ausdruck:', ZK)
    t(CONTRADICTION_THIS_PROVES, EN, 'Contradiction! This proves the original statement.', ZK)
    t(CONTRADICTION_THIS_PROVES, HU, 'Ellentmondás! Ezáltal az eredeti állítást igazoltuk.', ZK)
    t(CONTRADICTION_THIS_PROVES, DE, 'Widerspruch! So wurde die ursprüngliche Aussage bewiesen.', ZK)
    t(DIFFICULTY_A, EN, 'The statement has a difficulty of degree %0.', ZK)
    t(DIFFICULTY_A, HU, 'Az állítás nehézségi foka: %0.', ZK)
    t(DIFFICULTY_A, DE, 'Der Schwierigkeitsgrad der Aussage ist %0.', ZK)
    t(PROOF_PREPARATION_SEEMS_DIFFICULT, EN, 'The preparation of the proof seems computationally too difficult, sorry.', ZK)
    t(PROOF_PREPARATION_SEEMS_DIFFICULT, HU, 'A bizonyítás lépéseinek előkészítése sajnos túl számításigényes.', ZK)
    t(PROOF_PREPARATION_SEEMS_DIFFICULT, DE, 'Leider ist die Vorbereitung der Beweisschritte zu kompliziert.', ZK)
    t(FORCING_NON_COLLINEARITY, EN, 'Forcing non-collinearity for certain point triplets:', ZK)
    t(FORCING_NON_COLLINEARITY, HU, 'Bizonyos háromszögek nem lehetnek elfajulóak:', ZK)
    t(FORCING_NON_COLLINEARITY, DE, 'Manche Dreiecke dürfen nicht entartet sein:', ZK)
    t(ONLY_FIRST_FIXED_EXPRESSION, EN, 'Only the first free point can be fixed, because the thesis is an expression.', ZK)
    t(ONLY_FIRST_FIXED_EXPRESSION, HU, 'Csak az első pont rögzíthető, mert a bizonyítandó állítás egy kifejezés.', ZK)
    t(ONLY_FIRST_FIXED_EXPRESSION, DE, 'Nur der erste Punkt kann fixiert werden, weil die Konsequenz ein Ausdruck ist.', ZK)
    t(A_VALUE_OF_CENTER_OF_B, EN, '%0 value of center of %1', ZK)
    t(A_VALUE_OF_CENTER_OF_B, HU, '%1 középpontjának %0-koordinátája', ZK)
    t(A_VALUE_OF_CENTER_OF_B, DE, '%0-Koordinate des Mittelpunktes von %1', ZK)
    t(A_VALUE_OF_A_POINT_OF_B, EN, '%0 value of a point of %1', ZK)
    t(A_VALUE_OF_A_POINT_OF_B, DE, '%0-Koordinate eines Punktes von %1', ZK)
    t(A_VALUE_OF_A_POINT_OF_B, HU, '%1 egy pontjának %0-koordinátája', ZK)
    t(A_VALUE_OF_AN_IMPLICITLY_INTRODUCED_FOOT_POINT_FOR_ORTHOGONAL_LINE_AT_B_TO_C, EN, '%0 value of an implicitly introduced foot point for orthogonal line at %1 to %2', ZK)
    t(A_VALUE_OF_AN_IMPLICITLY_INTRODUCED_FOOT_POINT_FOR_ORTHOGONAL_LINE_AT_B_TO_C, DE, '%0-Koordinate eines implizit eingeführten Fußpunktes für senkrechte Gerade an %1 auf %2', ZK)
    t(A_VALUE_OF_AN_IMPLICITLY_INTRODUCED_FOOT_POINT_FOR_ORTHOGONAL_LINE_AT_B_TO_C, HU, 'A %1-ban/-ben %2-ra/-re merőlegesen állított egyenes talppontjának %0-koordinátája', ZK)
    t(A_VALUE_OF_MIDPOINT_OF_B, EN, '%0 value of midpoint of %1', ZK)
    t(A_VALUE_OF_MIDPOINT_OF_B, DE, '%0-Koordinate des Mittelpunkts von %1', ZK)
    t(A_VALUE_OF_MIDPOINT_OF_B, HU, '%1 felezőpontjának %0-koordinátája', ZK)
    t(A_VALUE_OF_ROTATION_OF_POINT_B_AROUND_THE_MIDPOINT_OF_C_BY_D_DEGREES, EN, '%0 value of rotation of point %1 around the midpoint of %2 by %3 degrees', ZK)
    t(A_VALUE_OF_ROTATION_OF_POINT_B_AROUND_THE_MIDPOINT_OF_C_BY_D_DEGREES, DE, '%0-Koordinate der Drehung des Punktes %1 um Mittelpunkt von %2 um %3 Grad', ZK)
    t(A_VALUE_OF_ROTATION_OF_POINT_B_AROUND_THE_MIDPOINT_OF_C_BY_D_DEGREES, HU, '%1 %0-koordinátája, miután %2 felezőpontja körül %3 fokkal elforgattuk', ZK)
    #
    t(SHOWPROOF, ES, 'VerDemo', TR)
    t(SHOWPROOF_SYNTAX, ES, '[ <Expresión Booleana> ]', TR)
    t(PROVE_THAT_A, ES, 'Demuestra que %0.', TR)
    t(LET_A_BE_ARBITRARY_POINTS, ES, 'Sean %0 puntos arbitrarios.', TR)
    t(LET_A_BE_THE_B, ES, 'Sea %0: %1.', TR)
    t(LET_A_BE_A_B, ES, 'Sea %0: %1.', TR)
    t(LET_A_BE_THE_REGULAR_POLYGON_BCD, ES, 'Sea %0 el %3-gono regular sobre el segmento %1, %2.', TR)
    t(LET_A_BE_THE_REGULAR_BGON_VERTICES_C, ES, 'Sea %0 el %1-gono con vértices %2.', TR)
    t(DENOTE_THE_EXPRESSION_A_BY_B, ES, 'Denotemos la expresión %0 como %1.', TR)
    t(PROOF_UNKNOWN, ES, 'La verdad de la proposición no ha podido ser comprobada ni negada.', TR)
    t(STATEMENT_ALWAYS_TRUE, ES, 'La proposición es siempre verdad.', TR)
    t(TRUE_ON_PARTS, ES, 'La proposición es parcialmente verdad, parcialmente falsa.', TR)
    t(TRUE_UNDER_NONDEGENERACY_CONDITIONS, ES, 'La proposición es verdad bajo ciertas condiciones de no degeneración (véase abajo).', TR)
    t(STATEMENT_FALSE, ES, 'La proposición es falsa.', TR)
    t(STATEMENT_TRIVIAL, ES, 'La proposición es trivial.', TR)
    t(PROVE_BY_CONTRADICTION, ES, 'Demostremos esto por contradicción.', TR)
    t(NO_FULL_PROOF, ES, 'Actualmente no podemos proporcionar una demostración completa, sólo algunos pasos.', TR)
    t(NO_FULL_PRESENTATION, ES, 'Internamente todos los pasos han sido verificados, pero una visualización completa de los mismos aún no está implementada.', TR)
    t(TRY_NEWER_VERSION, ES, 'Por favor, si es posible, intente usar una nueva versión de GeoGebra Discovery', TR)
    t(UNSUPPORTED_AXES_FIXED_SLOPE_LINES, ES, 'No se consideran  aquellas proposiciones que incluyen ejes o rectas de pendiente fija.', TR)
    t(CONSIDERING_DEFINITION_A, ES, 'Teniendo en cuenta la definición %0:', TR)
    t(LET_FREE_POINT_A_DENOTED_BY_B, ES, 'Denotemos el punto libre %0 como %1.', TR)
    t(ONLY_FIRST_FIXED_BECAUSE_A_ON_B, ES, 'Sólo es posible fijar el primer punto libre, porque %0 está en la línea %1.', TR)
    t(LET_DEPENDENT_POINT_A_DENOTED_BY_B, ES, 'Denotemos el punto dependiente %0 como %1.', TR)
    t(OBJECT_A_INTRODUCES, ES, 'El objeto %0 introduce las siguientes variables extra:', TR)
    t(COMMAND_A_NOT_FULLY_IMPLEMENTED, ES, 'El comando %0 no está totalmente implementado en el demostrador.', TR)
    t(COMMAND_A_NOT_IMPLEMENTED, ES, 'El comando %0 no está implementado en el demostrador.', TR)
    t(THESIS_EQS_NON_DENIED, ES, 'Ecuaciones (afirmativas) de la tesis:', TR)
    t(THESIS_EQ_DENIED, ES, 'Tesis por reducción al absurdo (negación de la proposición):', TR)
    t(DUMMY_VAR_NEG, ES, 'varible muda para expresar negación', TR)
    t(STATEMENT_A_NOT_FULLY_IMPLEMENTED, ES, 'La proposición %0 no está totalmente implementada en el demostrador.', TR)
    t(STATEMENT_A_NOT_IMPLEMENTED, ES, 'La proposición %0 no está implementada en el demostrador.', TR)
    t(WLOG_COORDINATES, ES, 'Sin pérdida de generalidad podemos fijar algunas coordenadas:', TR)
    t(CANNOT_DECIDE_ALGEBRAIC_DIFFICULTIES, ES, 'Perdón, el programa no puede concluir nada por ciertas dificultades algebraicas.', TR)
    t(STATEMENT_ALGEBRAICALLY_TRUE_GEOMETRICALLY_AMBIGUOUS, ES, 'La proposición es algebraicamente cierta, pero geométricamente ambigua.', TR)
    t(STATEMENT_TRUE_NDG, ES, 'La proposición parece ser cierta bajo ciertas condiciones de no degeneración:', TR)
    t(AFTER_SUBS, ES, 'Tras las sustituciones:', TR)
    t(STATEMENT_TRUE_NDG_UNREADABLE, ES, 'La proposición es cierta bajo ciertas condiciones de no degeneración (que no pueden expresarse en términos geométricos simples):', TR)
    t(ALL_HYPOS_NEG_THESIS, ES, 'Todas las hipótesis, y la negación de la tesis, tras las sustituciones:', TR)
    t(NOW_CONSIDER, ES, 'Consideremos ahora la siguiente expresión:', TR)
    t(CONTRADICTION_THIS_PROVES, ES, 'Contradicción! Lo que prueba la proposición original.', TR)
    t(DIFFICULTY_A, ES, 'La proposición tiene dificultad de grado %0.', TR)
    t(PROOF_PREPARATION_SEEMS_DIFFICULT, ES, 'Perdón, la preparación de la demostración parece ser, computacionalmente, demasiado difícil.', TR)
    t(FORCING_NON_COLLINEARITY, ES, 'Forzar la no colinealidad para determinadas tripletas de puntos.', ZK)
    t(ONLY_FIRST_FIXED_EXPRESSION, ES, 'Sólo se puede fijar el primer punto libre, porque la tesis es una expresión.', ZK)
    t(A_VALUE_OF_AN_IMPLICITLY_INTRODUCED_FOOT_POINT_FOR_ORTHOGONAL_LINE_AT_B_TO_C, ES, 'La coordenada %0 del pie implicitamente introducido de la recta ortogonal a %1 por %2', TR)
    t(A_VALUE_OF_MIDPOINT_OF_B, ES, 'La coordenada %0 del punto medio de %1', TR)
    t(A_VALUE_OF_ROTATION_OF_POINT_B_AROUND_THE_MIDPOINT_OF_C_BY_D_DEGREES, ES, 'La coordenada %0 del punto resultante del giro de %3 grados del punto %1 alrededor del punto medio de %2', TR)

    c(REALQUANTIFIERELIMINATION, 'RealQuantifierElimination')
    c(REALQUANTIFIERELIMINATION_SYNTAX, 'RealQuantifierElimination.Syntax')
    t(REALQUANTIFIERELIMINATION, EN, 'RealQuantifierElimination', ZK)
    t(REALQUANTIFIERELIMINATION, DE, 'ReelleQuantorenelimination', ZK)
    t(REALQUANTIFIERELIMINATION, ES, 'REC', ZK)
    t(REALQUANTIFIERELIMINATION, HU, 'ValósKvantorelimináció', ZK)
    t(REALQUANTIFIERELIMINATION_SYNTAX, EN, '[ <Expression> ]', ZK)
    t(REALQUANTIFIERELIMINATION_SYNTAX, DE, '[ <Ausdruck> ]', ZK)
    t(REALQUANTIFIERELIMINATION_SYNTAX, ES, '[ <Expresión> ]', ZK)
    t(REALQUANTIFIERELIMINATION_SYNTAX, HU, '[ <Kifejezés> ]', ZK)

    c(STEPWISEDISCOVERY, 'StepwiseDiscovery')
    c(STEPWISEDISCOVERY_SYNTAX, 'StepwiseDiscovery.Syntax')
    t(STEPWISEDISCOVERY, EN, 'StepwiseDiscovery', ZK)
    t(STEPWISEDISCOVERY, DE, 'SchrittweisesEntdecken', ZK)
    t(STEPWISEDISCOVERY, HU, 'FelfedezésLépésenként', ZK)
    t(STEPWISEDISCOVERY, ES, 'DescubrimientoProgresivo', ZK)
    t(STEPWISEDISCOVERY_SYNTAX, EN, "[ ]\n[ <Boolean> ]", ZK)
    t(STEPWISEDISCOVERY_SYNTAX, DE, "[ ]\n[ <Wahrheitswert> ]", ZK)
    t(STEPWISEDISCOVERY_SYNTAX, HU, "[ ]\n[ <Logikai érték> ]", ZK)
    t(STEPWISEDISCOVERY_SYNTAX, ES, "[ ]\n[ <Valor lógico> ]", ZK)
    m(STEPWISEDISCOVERY_INFORMATION, 'Information')
    t(STEPWISEDISCOVERY_INFORMATION, EN, 'Information', ZK)
    t(STEPWISEDISCOVERY_INFORMATION, DE, 'Information', ZK)
    t(STEPWISEDISCOVERY_INFORMATION, HU, 'Információ', ZK)
    t(STEPWISEDISCOVERY_INFORMATION, ES, 'Información', ZK)
    m(STEPWISEDISCOVERY_ENABLED, 'StepwiseDiscoveryEnabled')
    t(STEPWISEDISCOVERY_ENABLED, EN, 'The stepwise discovery mode is enabled.', ZK)
    t(STEPWISEDISCOVERY_ENABLED, DE, 'Schrittweises Entdecken ist eingeschaltet.', ZK)
    t(STEPWISEDISCOVERY_ENABLED, HU, 'A lépésenkénti felfedezés mód bekapcsolva.', ZK)
    t(STEPWISEDISCOVERY_ENABLED, ES, 'El descubrimiento progresivo está activada.', ZK)
    m(STEPWISEDISCOVERY_DISABLED, 'StepwiseDiscoveryDisabled')
    t(STEPWISEDISCOVERY_DISABLED, EN, 'The stepwise discovery mode is disabled.', ZK)
    t(STEPWISEDISCOVERY_DISABLED, DE, 'Schrittweises Entdecken ist ausgeschaltet.', ZK)
    t(STEPWISEDISCOVERY_DISABLED, HU, 'A lépésenkénti felfedezés mód kikapcsolva.', ZK)
    t(STEPWISEDISCOVERY_DISABLED, ES, 'El descubrimiento progresivo está desactivada.', ZK)
    m(STEPWISEDISCOVERY_STYLEBAR, 'stylebar.Discover')
    t(STEPWISEDISCOVERY_STYLEBAR, EN, 'Switch stepwise discovery on or off', ZK)
    t(STEPWISEDISCOVERY_STYLEBAR, DE, 'Schrittweises Entdecken ein- oder ausschalten', ZK)
    t(STEPWISEDISCOVERY_STYLEBAR, HU, 'Lépésenkénti felfedezés mód be- vagy kikapcsolása', ZK)
    t(STEPWISEDISCOVERY_STYLEBAR, ES, 'Activa o desactiva el descubrimiento progresivo', ZK)

    m(EXPORT_AS_LATEX, 'ExportAsLaTeX')
    t(EXPORT_AS_LATEX, EN, 'Export as LaTeX', ZK)
    t(EXPORT_AS_LATEX, DE, 'Export als LaTeX', ZK)
    t(EXPORT_AS_LATEX, HU, 'Exportálás LaTeX-ként', ZK)
    t(EXPORT_AS_LATEX, ES, 'Exportar como LaTeX', ZK)

    c(PLOT2D, 'Plot2D')
    c(PLOT2D_SYNTAX, 'Plot2D.Syntax')
    t(PLOT2D, EN, 'Plot2D', ZK)
    t(PLOT2D, DE, 'Zeichne2D', ZK)
    t(PLOT2D, ES, 'Grafica2D', ZK)
    t(PLOT2D, HU, 'Rajzol2D', ZK)
    t(PLOT2D_SYNTAX, EN, '[ <Function> ]', ZK)
    t(PLOT2D_SYNTAX, DE, '[ <Funktion> ]', ZK)
    t(PLOT2D_SYNTAX, ES, '[ <Función> ]', ZK)
    t(PLOT2D_SYNTAX, HU, '[ <Függvény> ]', ZK)
