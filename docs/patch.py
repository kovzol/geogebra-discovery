#!/usr/bin/env python
# -*- coding: utf-8 -*-

# This program adds extra entries in the ggbtrans database.
# These extra entries are not (yet) official properties and translations.
# Currently this program is used to maintain an extended translation database for GeoGebra Discovery,
# see https://github.com/kovzol/geogebra-discovery for details.
# Author: Zoltán Kovács <zoltan@geogebra.org>

# Usage:
# 1. Add entries in the main program (see below, at the end of this file). Don't delete existing entries, just add new ones.
# 2. Copy the raw ggbtransdb file from the current database to this folder.
# 3. Run this program.
# 4. Create an output folder, e.g. output-trunk, with "mkdir output-trunk".
# 5. Run "./export.py trunk output-trunk ggbtransdb".
# 6. Copy the contents of the output-trunk folder to fork/geogebra/common-jre/src/nonfree/resources/org/geogebra/common/jre/properties
#    in your local repository of GeoGebra Discovery.
# 7. Create another output folder, e.g. output-gwtjs, with "mkdir output-gwtjs".
# 8. Run "./export.py gwtjs output-gwtjs ggbtransdb".
# 9. Copy the contents of the output-trunk folder to fork/geogebra/web/src/nonfree/resources/org/geogebra/web/pub/js
#    in your local repository of GeoGebra Discovery.
# 10. Test the new translations.
# 11. Commit the changes in the fork/geogebra/ folder.

# We avoid overwriting or overlapping any existing or future entries, so we start our patching in a large ID area.
start_properties_translation_id = 1000000; # < 360000 on 2021-05-09
start_properties_property_id = 100000; # < 8000 on 2021-05-09

properties_translation_id = start_properties_translation_id
properties_property_id = start_properties_property_id

try:
    import sqlite3
except ImportError:
    import pysqlite2.dbapi2 as sqlite3

import shutil, time, optparse, os.path

def next_property_id():
    global properties_property_id
    properties_property_id += 1
    return properties_property_id

def add_property(properties_property_id, category_id, version, key):
    with sqlite3.connect("ggbtransdb") as conn:
        c = conn.cursor()
        query = "INSERT INTO properties_property (id, parent_id, category_id, version, comment, key, creation_date, modification_date, max_length, ticket) VALUES "
        query += "(" + str(properties_property_id) + ", NULL, " + str(category_id) + ", '" + str(version) + "', "
        query += "'created by a patch via patch.py', " + "'" + key + "', " + "DATE('now'), DATE('now'), NULL, NULL)"
        print(query)
        c.execute(query)

def add_translation(property_id, locale_id, text, author_id):
    with sqlite3.connect("ggbtransdb") as conn:
        c = conn.cursor()
        global properties_translation_id
        properties_translation_id += 1
        query = "INSERT INTO properties_translation (id, property_id, locale_id, text, comment, creation_date, modification_date, author_id) VALUES "
        text = text.replace("'", "''")
        query += "(" + str(properties_translation_id) + ", " + str(property_id) + ", " + str(locale_id) + ", " + "'" + text + "', "
        query += "'created by a patch via patch.py', DATE('now'), DATE('now'), " + str(author_id) + ")"
        print(query)
        c.execute(query)

def add_command(properties_property_id, key):
    add_property(properties_property_id, 2, 'stable', key)

def add_menu(properties_property_id, key):
    add_property(properties_property_id, 5, 'stable', key)

# Abbreviations
def m(properties_property_id, key):
    add_menu(properties_property_id, key)
def c(properties_property_id, key):
    add_command(properties_property_id, key)
def t(property_id, locale_id, text, author_id):
    add_translation(property_id, locale_id, text, author_id)
def n():
    return next_property_id()


def cleanup():
    with sqlite3.connect("ggbtransdb") as conn:
        c = conn.cursor()
        global start_properties_translation_id
        query = "DELETE from properties_translation WHERE id > " + str(start_properties_translation_id)
        print(query)
        c.execute(query)
        global start_properties_property_d
        query = "DELETE from properties_property WHERE id > " + str(start_properties_property_id)
        print(query)
        c.execute(query)

if __name__ == "__main__":
    # Delete eventually existing former extra entries:
    cleanup()

    # Create IDs for new properties.

    DISCOVER = n()
    DISCOVER_SYNTAX = n()
    DISCOVER_TOOL = n()
    DISCOVER_TOOL_HELP = n()
    DISCOVERED_THEOREMS_ON_POINT = n()
    NO_THEOREMS_FOUND = n()
    REDRAW_DIFFERENTLY = n()
    UNSUPPORTED_STEPS = n()
    IDENTICAL_POINTS_A = n()
    COLLINEAR_POINTS_A = n()
    CONCYCLIC_POINTS_A = n()
    SETS_OF_PARALLEL_AND_PERPENDICULAR_LINES_A = n()
    CONGRUENT_SEGMENTS_A = n()
    IN_PROGRESS = n()
    CANNOT_DECIDE_EQUALITY_OF_POINTS_A_B = n()

    COMPARE = n()
    COMPARE_SYNTAX = n()
    COMPARE_A_AND_B = n()

    INCIRCLECENTER = n()
    INCIRCLECENTER_SYNTAX = n()
    INCIRCLECENTER_TOOL = n()
    INCIRCLECENTER_TOOL_HELP = n()

    INCIRCLE_TOOL = n()
    INCIRCLE_TOOL_HELP = n()

    LOCUSEQUATION_TOOL = n()
    LOCUSEQUATION_TOOL_HELP = n()

    ENVELOPE_TOOL = n()
    ENVELOPE_TOOL_HELP = n()

    SHOWPROOF = n()
    SHOWPROOF_SYNTAX = n()
    PROVE_THAT_A = n()
    LET_A_BE_ARBITRARY_POINTS = n()
    LET_A_BE_AN_ARBITRARY_POINT = n()
    LET_A_BE_THE_B = n()
    LET_A_BE_A_B = n()
    LET_A_BE_THE_REGULAR_POLYGON_BCD = n()
    LET_A_BE_THE_REGULAR_BGON_VERTICES_C = n()
    DENOTE_THE_EXPRESSION_A_BY_B = n()
    PROOF_UNKNOWN = n()
    STATEMENT_ALWAYS_TRUE = n()
    TRUE_ON_PARTS = n()
    TRUE_UNDER_NONDEGENERACY_CONDITIONS = n()
    STATEMENT_FALSE = n()
    STATEMENT_TRIVIAL = n()
    PROVE_BY_CONTRADICTION = n()
    NO_FULL_PROOF = n()
    NO_FULL_PRESENTATION = n()
    TRY_NEWER_VERSION = n()
    UNSUPPORTED_AXES_FIXED_SLOPE_LINES = n()
    CONSIDERING_DEFINITION_A = n()
    LET_FREE_POINT_A_DENOTED_BY_B = n()
    ONLY_FIRST_FIXED_BECAUSE_A_ON_B = n()
    ONLY_FIRST_FIXED_EXPRESSION = n()
    LET_DEPENDENT_POINT_A_DENOTED_BY_B = n()
    OBJECT_A_INTRODUCES = n()
    COMMAND_A_NOT_FULLY_IMPLEMENTED = n()
    COMMAND_A_NOT_IMPLEMENTED = n()
    THESIS_EQS_NON_DENIED = n()
    THESIS_EQ_DENIED = n()
    DUMMY_VAR_NEG = n()
    STATEMENT_A_NOT_FULLY_IMPLEMENTED = n()
    STATEMENT_A_NOT_IMPLEMENTED = n()
    WLOG_COORDINATES = n()
    CANNOT_DECIDE_ALGEBRAIC_DIFFICULTIES = n()
    WEAKENING_TRUE = n()
    STATEMENT_TRUE_NDG = n()
    AFTER_SUBS = n()
    STATEMENT_TRUE_NDG_UNREADABLE = n()
    ALL_HYPOS_NEG_THESIS = n()
    NOW_CONSIDER = n()
    CONTRADICTION_THIS_PROVES = n()
    DIFFICULTY_A = n()
    PROOF_PREPARATION_SEEMS_DIFFICULT = n()
    FORCING_NON_COLLINEARITY = n()
    THESIS_A_IN_ALGEBRAIC_FORM = n()
    STATEMENT_REQUIRES_CONDITIONS = n()

    REALQUANTIFIERELIMINATION = n()
    REALQUANTIFIERELIMINATION_SYNTAX = n()

    STEPWISEDISCOVERY = n()
    STEPWISEDISCOVERY_SYNTAX = n()
    STEPWISEDISCOVERY_INFORMATION = n()
    STEPWISEDISCOVERY_ENABLED = n()
    STEPWISEDISCOVERY_DISABLED = n()
    STEPWISEDISCOVERY_STYLEBAR = n()

    EXPORT_AS_LATEX = n()
    CAS_MAPLE_TO_CLIPBOARD = n()
    CAS_MATHEMATICA_TO_CLIPBOARD = n()
    CAS_GIAC_TO_CLIPBOARD = n()
    CLEAR_CAS_VIEW = n()
    EXPORT_CAS_MAPLE = n()
    EXPORT_CAS_HTML = n()
    EXPORT_CAS_LATEX = n()
    EXPORT_CAS_MATHEMATICA = n()
    EXPORT_CAS_GIAC = n()

    PLOT2D = n()
    PLOT2D_SYNTAX = n()

    A_VALUE_OF_CENTER_OF_B = n()
    A_VALUE_OF_A_POINT_OF_B = n()
    A_VALUE_OF_AN_IMPLICITLY_INTRODUCED_SECOND_POINT_FOR_ORTHOGONAL_LINE_AT_B_TO_C = n()
    A_VALUE_OF_MIDPOINT_OF_B = n()
    A_VALUE_OF_ROTATION_OF_POINT_B_AROUND_THE_MIDPOINT_OF_C_BY_D_DEGREES = n()
    A_VALUE_OF_MIDPOINT_OF_RHOMBUS_ANGULAR_BISECTOR_B = n()
    A_VALUE_OF_HELPER_POINT_MIRROR_B_C_ABOUT_D_E = n()

    VARIABLE_A_IS_ALREADY_DEFINED_PLEASE_REMOVE_IT_FIRST = n()
    PLEASE_OPEN_THE_CAS_VIEW_FIRST = n()

    PROVER_TIMEOUT = n()
    GEOGEBRA_CANNOT_CHECK = n()

    # Languages
    EN = 1
    DE = 6
    ES = 9
    FR = 14
    HE = 20
    HU = 16
    AR = 40
    TRK = 37
    IT = 19

    # Authors
    ZK = 34 # Zoltán Kovács
    TR = 34 # Tomás Recio (fake)
    BP = 197 # Bernard Parisse
    ND = 34 # Noah Dana-Picard (fake)
    HK = 445 # Houssam Kasti
    SG = 34 # Selen Galic (fake)
    SR = 6 # Simona Riva
    NL = 8 # Noël Lambert

    # Properties
    c(DISCOVER, 'Discover')
    c(DISCOVER_SYNTAX, 'Discover.Syntax')
    m(DISCOVER_TOOL, 'Discover')
    m(DISCOVER_TOOL_HELP, 'Discover.Help')
    m(DISCOVERED_THEOREMS_ON_POINT, 'DiscoveredTheoremsOnPointA')
    m(NO_THEOREMS_FOUND, 'NoTheoremsFound')
    m(REDRAW_DIFFERENTLY, 'RedrawDifferently')
    m(UNSUPPORTED_STEPS, 'UnsupportedSteps')
    m(CONCYCLIC_POINTS_A, 'ConcyclicPointsA')
    m(IDENTICAL_POINTS_A, 'IdenticalPointsA')
    m(COLLINEAR_POINTS_A, 'CollinearPointsA')
    m(CONGRUENT_SEGMENTS_A, 'CongruentSegmentsA')
    m(SETS_OF_PARALLEL_AND_PERPENDICULAR_LINES_A, 'SetsOfParallelAndPerpendicularLinesA')
    m(IN_PROGRESS, 'InProgress')
    m(CANNOT_DECIDE_EQUALITY_OF_POINTS_A_B, 'CannotDecideEqualityofPointsAB')
    t(DISCOVER, EN, 'Discover', ZK)
    t(DISCOVER, DE, 'Entdecken', ZK)
    t(DISCOVER, ES, 'Descubrir', ZK)
    t(DISCOVER, HU, 'Felfedezés', ZK)
    t(DISCOVER_TOOL, EN, 'Discover', ZK)
    t(DISCOVER_TOOL, DE, 'Entdecken', ZK)
    t(DISCOVER_TOOL, ES, 'Descubrir', ZK)
    t(DISCOVER_TOOL, HU, 'Felfedezés', ZK)
    t(DISCOVER_TOOL_HELP, EN, 'Select one point', ZK)
    t(DISCOVER_TOOL_HELP, HU, 'Egy pont kijelölése', ZK)
    t(DISCOVER_TOOL_HELP, DE, 'Gib einen Punkt an', ZK)
    t(DISCOVER_TOOL_HELP, ES, 'Selecciona punto', ZK)
    t(DISCOVERED_THEOREMS_ON_POINT, EN, 'Discovered theorems on point %0', ZK)
    t(DISCOVERED_THEOREMS_ON_POINT, DE, 'Entdeckungen über den Punkt %0', ZK)
    t(DISCOVERED_THEOREMS_ON_POINT, ES, 'Teoremas descubiertos con el punto %0', ZK)
    t(DISCOVERED_THEOREMS_ON_POINT, HU, 'A(z) %0 ponttal kapcsolatos felfedezések', ZK)
    t(DISCOVER_SYNTAX, EN, '[ <Point> ]', ZK)
    t(DISCOVER_SYNTAX, DE, '[ <Punkt> ]', ZK)
    t(DISCOVER_SYNTAX, HU, '[ <Pont> ]', ZK)
    t(DISCOVER_SYNTAX, ES, '[ <Punto> ]', ZK)
    t(NO_THEOREMS_FOUND, EN, 'No theorems were found.', ZK)
    t(NO_THEOREMS_FOUND, DE, 'Keine Sätze wurden gefunden.', ZK)
    t(NO_THEOREMS_FOUND, HU, 'Nincs semmi figyelemreméltó.', ZK)
    t(NO_THEOREMS_FOUND, ES, 'No se encontraron teoremas descubiertos.', ZK)
    t(REDRAW_DIFFERENTLY, EN, 'Try to redraw the construction differently.', ZK)
    t(REDRAW_DIFFERENTLY, DE, 'Versuchen Sie, die Konstruktion anders zu zeichnen.', ZK)
    t(REDRAW_DIFFERENTLY, HU, 'Próbálja újrarajzolni az ábrát másképpen!', ZK)
    t(REDRAW_DIFFERENTLY, ES, 'Intente volver a dibujar la figura de forma diferente.', ZK)
    t(UNSUPPORTED_STEPS, EN, 'The construction contains unsupported steps.', ZK)
    t(UNSUPPORTED_STEPS, ES, 'La figura consta de pasos no compatibles.', ZK)
    t(UNSUPPORTED_STEPS, DE, 'Die Konstruktion enthält Schritte, die nicht unterstützt sind.', ZK)
    t(UNSUPPORTED_STEPS, HU, 'Nem támogatott lépéseket tartalmaz a szerkesztés.', ZK)
    t(IDENTICAL_POINTS_A, EN, 'Identical points: %0', ZK)
    t(IDENTICAL_POINTS_A, DE, 'Identische Punkte: %0', ZK)
    t(IDENTICAL_POINTS_A, ES, 'Puntos idénticos: %0', ZK)
    t(IDENTICAL_POINTS_A, HU, 'Megegyező pontok: %0', ZK)
    t(COLLINEAR_POINTS_A, EN, 'Collinear points: %0', ZK)
    t(COLLINEAR_POINTS_A, DE, 'Kollineare Punkte: %0', ZK)
    t(COLLINEAR_POINTS_A, ES, 'Puntos colineales: %0', ZK)
    t(COLLINEAR_POINTS_A, HU, 'Kollineáris pontok: %0', ZK)
    t(CONCYCLIC_POINTS_A, EN, 'Concyclic points: %0', ZK)
    t(CONCYCLIC_POINTS_A, DE, 'Konzyklische Punkte: %0', ZK)
    t(CONCYCLIC_POINTS_A, ES, 'Puntos concíclicos: %0', ZK)
    t(CONCYCLIC_POINTS_A, HU, 'Egy körre illeszkedő pontok: %0', ZK)
    t(CONGRUENT_SEGMENTS_A, EN, 'Congruent segments: %0', ZK)
    t(CONGRUENT_SEGMENTS_A, DE, 'Kongruente Strecken: %0', ZK)
    t(CONGRUENT_SEGMENTS_A, ES, 'Segmentos congruentes: %0', ZK)
    t(CONGRUENT_SEGMENTS_A, HU, 'Egybevágó szakaszok: %0', ZK)
    t(SETS_OF_PARALLEL_AND_PERPENDICULAR_LINES_A, EN, 'Sets of parallel and perpendicular lines: %0', ZK)
    t(SETS_OF_PARALLEL_AND_PERPENDICULAR_LINES_A, DE, 'Mengen von parallelen und senkrechten Geraden: %0', ZK)
    t(SETS_OF_PARALLEL_AND_PERPENDICULAR_LINES_A, ES, 'Líneas paralelas y perpendiculares: %0', ZK)
    t(SETS_OF_PARALLEL_AND_PERPENDICULAR_LINES_A, HU, 'Párhuzamos és merőleges egyenesek: %0', ZK)
    t(IN_PROGRESS, EN, 'In progress', ZK)
    t(IN_PROGRESS, DE, 'In Bearbeitung', ZK)
    t(IN_PROGRESS, ES, 'En curso', ZK)
    t(IN_PROGRESS, HU, 'Folyamatban', ZK)
    t(CANNOT_DECIDE_EQUALITY_OF_POINTS_A_B, EN, 'Cannot decide equality of points %0 and %1.', ZK)
    t(CANNOT_DECIDE_EQUALITY_OF_POINTS_A_B, DE, 'Kann die Gleichheit der Punkte %0 und %1 nicht entscheiden.', ZK)
    t(CANNOT_DECIDE_EQUALITY_OF_POINTS_A_B, ES, 'No se puede decidir la igualdad de los puntos %0 y %1.', ZK)
    t(CANNOT_DECIDE_EQUALITY_OF_POINTS_A_B, HU, 'Nem tudom eldönteni, hogy a(z) %0 és %1 pontok megegyeznek-e.', ZK)

    c(COMPARE, 'Compare')
    c(COMPARE_SYNTAX, 'Compare.Syntax')
    m(COMPARE_A_AND_B, 'CompareAandB')
    t(COMPARE, EN, 'Compare', ZK)
    t(COMPARE, DE, 'Vergleiche', ZK)
    t(COMPARE, ES, 'Compara', ZK)
    t(COMPARE, HU, 'Összehasonlít', ZK)
    t(COMPARE_SYNTAX, EN, '[ <Expression>, <Expression> ]', ZK)
    t(COMPARE_SYNTAX, ES, '[ <Expresión>, <Expresión> ]', ZK)
    t(COMPARE_SYNTAX, DE, '[ <Ausdruck>, <Ausdruck> ]', ZK)
    t(COMPARE_SYNTAX, HU, '[ <Kifejezés>, <Kifejezés> ]', ZK)
    t(COMPARE_A_AND_B, EN, 'Compare %0 and %1.', ZK)

    c(INCIRCLECENTER, 'IncircleCenter')
    c(INCIRCLECENTER_SYNTAX, 'IncircleCenter.Syntax')
    m(INCIRCLECENTER_TOOL, 'IncircleCenter')
    m(INCIRCLECENTER_TOOL_HELP, 'IncircleCenter.Help')
    t(INCIRCLECENTER, EN, 'IncircleCenter', ZK)
    t(INCIRCLECENTER, HU, 'BeírtKörKözéppontja', ZK)
    t(INCIRCLECENTER, DE, 'Inkreismittelpunkt', ZK)
    t(INCIRCLECENTER, ES, 'CentroCircunferenciaInscrita', ZK)
    t(INCIRCLECENTER_SYNTAX, EN, '[ <Point>, <Point>, <Point> ]', ZK)
    t(INCIRCLECENTER_SYNTAX, HU, '[ <Pont>, <Pont>, <Pont> ]', ZK)
    t(INCIRCLECENTER_SYNTAX, DE, '[ <Punkt>, <Punkt>, <Punkt> ]', ZK)
    t(INCIRCLECENTER_SYNTAX, ES, '[ <Punto>, <Punto>, <Punto> ]', ZK)
    t(INCIRCLECENTER_TOOL, ES, 'Centro de la circunferencia inscrita', ZK)
    t(INCIRCLECENTER_TOOL, EN, 'Incircle Center', ZK)
    t(INCIRCLECENTER_TOOL, DE, 'Inkreismittelpunkt', ZK)
    t(INCIRCLECENTER_TOOL, HU, 'Beírt kör középpontja', ZK)
    t(INCIRCLECENTER_TOOL_HELP, EN, 'Select three points', ZK)
    t(INCIRCLECENTER_TOOL_HELP, ES, 'Selecciona tres puntos', ZK)
    t(INCIRCLECENTER_TOOL_HELP, DE, 'Gib drei Punkte an', ZK)
    t(INCIRCLECENTER_TOOL_HELP, HU, 'Három pont kijelölése', ZK)

    m(INCIRCLE_TOOL, 'Incircle')
    m(INCIRCLE_TOOL_HELP, 'Incircle.Help')
    t(INCIRCLE_TOOL, EN, 'Incircle', ZK)
    t(INCIRCLE_TOOL, DE, 'Inkreis', ZK)
    t(INCIRCLE_TOOL, ES, 'Circunferencia inscrita', ZK)
    t(INCIRCLE_TOOL, HU, 'Beírt kör', ZK)
    t(INCIRCLE_TOOL_HELP, HU, 'Három pont kijelölése', ZK)
    t(INCIRCLE_TOOL_HELP, ES, 'Selecciona tres puntos', ZK)
    t(INCIRCLE_TOOL_HELP, DE, 'Gib drei Punkte an', ZK)
    t(INCIRCLE_TOOL_HELP, EN, 'Select three points', ZK)

    m(LOCUSEQUATION_TOOL, 'LocusEquation.Tool')
    m(LOCUSEQUATION_TOOL_HELP, 'LocusEquation.Help')
    t(LOCUSEQUATION_TOOL, ES, 'Ecuación Lugar Geométrico', ZK)
    t(LOCUSEQUATION_TOOL, DE, 'Ortsliniengleichung', ZK)
    t(LOCUSEQUATION_TOOL, EN, 'Locus Equation', ZK)
    t(LOCUSEQUATION_TOOL, HU, 'Mértani hely egyenlete', ZK)
    t(LOCUSEQUATION_TOOL_HELP, EN, 'Select locus point, then point on object', ZK)
    t(LOCUSEQUATION_TOOL_HELP, DE, 'Wähle einen Punkt zum Erzeugen der Ortslinie, dann einen Punkt auf einem Objekt', ZK)
    t(LOCUSEQUATION_TOOL_HELP, ES, 'Punto del lugar geométrico; luego, punto en objeto', ZK)
    t(LOCUSEQUATION_TOOL_HELP, HU, 'Mértani hely pontja, majd pont az objektumon', ZK)

    m(ENVELOPE_TOOL, 'Envelope.Tool')
    m(ENVELOPE_TOOL_HELP, 'Envelope.Help')
    t(ENVELOPE_TOOL, EN, 'Envelope', ZK)
    t(ENVELOPE_TOOL, DE, 'Einhüllende', ZK)
    t(ENVELOPE_TOOL, ES, 'Envolvente', ZK)
    t(ENVELOPE_TOOL, HU, 'Burkoló', ZK)
    t(ENVELOPE_TOOL_HELP, EN, 'Select path, then point on object', ZK)
    t(ENVELOPE_TOOL_HELP, DE, 'Gib eine Kurve an, dann einen Punkt auf einem Pfad', ZK)
    t(ENVELOPE_TOOL_HELP, ES, 'Trayecto del envolvente; luego, punto en objeto', ZK)
    t(ENVELOPE_TOOL_HELP, HU, 'Görbe, amelynek burkolóját keressük, majd egy alakzaton mozgó pont', ZK)

    c(SHOWPROOF, 'ShowProof')
    c(SHOWPROOF_SYNTAX, 'ShowProof.Syntax')
    m(PROVE_THAT_A, 'ProveThatA')
    m(LET_A_BE_ARBITRARY_POINTS, 'LetABeArbitraryPoints')
    m(LET_A_BE_AN_ARBITRARY_POINT, 'LetABeAnArbitraryPoint') # FR, HE, AR
    m(LET_A_BE_THE_B, 'LetABeTheB')
    m(LET_A_BE_A_B, 'LetABeAB')
    m(LET_A_BE_THE_REGULAR_POLYGON_BCD, 'LetABeTheRegularPolygonBCD')
    m(LET_A_BE_THE_REGULAR_BGON_VERTICES_C, 'LetABeTheRegularBGonVerticesC')
    m(DENOTE_THE_EXPRESSION_A_BY_B, 'DenoteTheExpressionAByB')
    m(PROOF_UNKNOWN, 'ProofUnknown')
    m(STATEMENT_ALWAYS_TRUE, 'StatementAlwaysTrue')
    m(TRUE_ON_PARTS, 'TrueOnParts')
    m(TRUE_UNDER_NONDEGENERACY_CONDITIONS, 'TrueUnderNondegeneracyConditions')
    m(STATEMENT_FALSE, 'StatementFalse')
    m(STATEMENT_TRIVIAL, 'StatementTrivial')
    m(PROVE_BY_CONTRADICTION, 'ProveByContradiction')
    m(NO_FULL_PROOF, 'NoFullProof')
    m(NO_FULL_PRESENTATION, 'NoFullPresentation')
    m(TRY_NEWER_VERSION, 'TryNewerVersion')
    m(UNSUPPORTED_AXES_FIXED_SLOPE_LINES, 'AxesFixedSlopeLinesUnsupportedSteps')
    m(CONSIDERING_DEFINITION_A, 'ConsideringDefinitionA')
    m(LET_FREE_POINT_A_DENOTED_BY_B, 'LetFreePointADenotedByB')
    m(ONLY_FIRST_FIXED_BECAUSE_A_ON_B, 'OnlyFirstFixedBecauseAOnB')
    m(ONLY_FIRST_FIXED_EXPRESSION, 'OnlyFirstFixedExpression')
    m(LET_DEPENDENT_POINT_A_DENOTED_BY_B, 'LetDependentPointADenotedByB')
    m(OBJECT_A_INTRODUCES, 'ObjectAIntroduces')
    m(COMMAND_A_NOT_FULLY_IMPLEMENTED, 'CommandANotFullyImplemented')
    m(COMMAND_A_NOT_IMPLEMENTED, 'CommandANotImplemented')
    m(THESIS_EQS_NON_DENIED, 'ThesisEqsNonDenied')
    m(THESIS_EQ_DENIED, 'ThesisEqDenied')
    m(DUMMY_VAR_NEG, 'DummyVarNeg')
    m(STATEMENT_A_NOT_FULLY_IMPLEMENTED, 'StatementANotFullyImplemented')
    m(STATEMENT_A_NOT_IMPLEMENTED, 'StatementANotImplemented')
    m(WLOG_COORDINATES, 'WlogCoordinates')
    m(CANNOT_DECIDE_ALGEBRAIC_DIFFICULTIES, 'CannotDecideAlgebraicDifficulties')
    m(WEAKENING_TRUE, 'WeakeningTrue')
    m(STATEMENT_TRUE_NDG, 'StatementTrueNdg')
    m(AFTER_SUBS, 'AfterSubs')
    m(STATEMENT_TRUE_NDG_UNREADABLE, 'StatementTrueNdgUnreadable')
    m(ALL_HYPOS_NEG_THESIS, 'AllHyposNegThesis')
    m(NOW_CONSIDER, 'NowConsider')
    m(CONTRADICTION_THIS_PROVES, 'ContradictionThisProves')
    m(DIFFICULTY_A, 'DifficultyA')
    m(PROOF_PREPARATION_SEEMS_DIFFICULT, 'ProofPreparationSeemsDifficult')
    m(FORCING_NON_COLLINEARITY, 'ForcingNonCollinearity')
    m(THESIS_A_IN_ALGEBRAIC_FORM, 'ThesisAInAlgebraicForm')
    m(STATEMENT_REQUIRES_CONDITIONS, 'StatementRequiresConditions') # FR, HE, AR
    m(A_VALUE_OF_CENTER_OF_B, 'AValueOfCenterOfB')
    m(A_VALUE_OF_A_POINT_OF_B, 'AValueOfAPointOfB')
    m(A_VALUE_OF_AN_IMPLICITLY_INTRODUCED_SECOND_POINT_FOR_ORTHOGONAL_LINE_AT_B_TO_C, 'AValueOfAnImplicitlyIntroducedSecondPointForOrthogonalLineAtBToC')
    m(A_VALUE_OF_MIDPOINT_OF_B, 'AValueOfMidpointOfB')
    m(A_VALUE_OF_ROTATION_OF_POINT_B_AROUND_THE_MIDPOINT_OF_C_BY_D_DEGREES, 'AValueOfRotationOfPointBAroundTheMidpointOfCByDDegrees')
    m(A_VALUE_OF_MIDPOINT_OF_RHOMBUS_ANGULAR_BISECTOR_B, 'AValueOfMidpointOfRhombusAngularBisectorB')
    m(A_VALUE_OF_HELPER_POINT_MIRROR_B_C_ABOUT_D_E, 'AValueOfHelperPointMirrorBCAboutDE')

    m(VARIABLE_A_IS_ALREADY_DEFINED_PLEASE_REMOVE_IT_FIRST, 'VariableAIsAlreadyDefinedPleaseRemoveItFirst')
    m(PLEASE_OPEN_THE_CAS_VIEW_FIRST, 'PleaseOpenTheCASViewFirst')
    m(PROVER_TIMEOUT, 'ProverTimeout') # FR, HE, AR
    m(GEOGEBRA_CANNOT_CHECK, 'GeoGebraCannotCheck') # FR, HE, AR
    #
    t(SHOWPROOF, EN, 'ShowProof', ZK)
    t(SHOWPROOF, HU, 'BizonyításLépései', ZK)
    t(SHOWPROOF, DE, 'BeweisSchritte', ZK)
    t(SHOWPROOF_SYNTAX, EN, '[ <Boolean Expression> ]', ZK)
    t(SHOWPROOF_SYNTAX, HU, '[ <Logikai kifejezés> ]', ZK)
    t(SHOWPROOF_SYNTAX, DE, '[ <Boolscher Ausdruck> ]', ZK)
    t(PROVE_THAT_A, EN, 'Prove that %0.', ZK)
    t(PROVE_THAT_A, HU, 'Bizonyítsuk be, hogy %0.', ZK)
    t(PROVE_THAT_A, DE, 'Beweise Folgendes: %0.', ZK)
    t(LET_A_BE_ARBITRARY_POINTS, EN, 'Let %0 be arbitrary points.', ZK)
    t(LET_A_BE_ARBITRARY_POINTS, HU, 'Legyenek %0 tetszőleges pontok.', ZK)
    t(LET_A_BE_ARBITRARY_POINTS, DE, 'Seien %0 beliebige Punkte.', ZK)
    t(LET_A_BE_AN_ARBITRARY_POINT, EN, 'Let %0 be an arbitrary points.', ZK)
    t(LET_A_BE_AN_ARBITRARY_POINT, HU, 'Legyen %0 tetszőleges pont.', ZK)
    t(LET_A_BE_AN_ARBITRARY_POINT, DE, 'Sei %0 ein beliebiger Punkt.', ZK)
    t(LET_A_BE_THE_B, EN, 'Let %0 be the %1.', ZK)
    t(LET_A_BE_THE_B, HU, 'Legyen %0 a(z) %1.', ZK)
    t(LET_A_BE_THE_B, DE, 'Sei %0: %1.', ZK)
    t(LET_A_BE_A_B, EN, 'Let %0 be a %1.', ZK)
    t(LET_A_BE_A_B, HU, 'Legyen %0 %1.', ZK)
    t(LET_A_BE_A_B, DE, 'Sei %0 %1.', ZK)
    t(LET_A_BE_THE_REGULAR_POLYGON_BCD, EN, 'Let %0 be the regular %3-gon over the segment %1, %2.', ZK)
    t(LET_A_BE_THE_REGULAR_POLYGON_BCD, HU, 'Legyen %0 a(z) %1, %2 szakasz fölé írt szabályos %3-szög.', ZK)
    t(LET_A_BE_THE_REGULAR_POLYGON_BCD, DE, 'Sei %0 das regelmäßige $3-Eck über der Strecke %1, %2.', ZK)
    t(LET_A_BE_THE_REGULAR_BGON_VERTICES_C, EN, 'Let %0 be the regular %1-gon with vertices %2.', ZK)
    t(LET_A_BE_THE_REGULAR_BGON_VERTICES_C, HU, 'Legyen %0 szabályos %1-szög a(z) %2 csúcsokkal.', ZK)
    t(LET_A_BE_THE_REGULAR_BGON_VERTICES_C, DE, 'Sei %0 das regelmäßige %1-Eck mit Eckpunkten %2.', ZK)
    t(DENOTE_THE_EXPRESSION_A_BY_B, EN, 'Denote the expression %0 by %1.', ZK)
    t(DENOTE_THE_EXPRESSION_A_BY_B, HU, 'Jelölje %1 a(z) %0 kifejezést.', ZK)
    t(DENOTE_THE_EXPRESSION_A_BY_B, DE, 'Sei der Ausdruck %0 beschriftet mit %1.', ZK)
    t(PROOF_UNKNOWN, EN, 'The statement could not be proven nor disproven.', ZK)
    t(PROOF_UNKNOWN, HU, 'Az állítást sem bizonyítani, sem cáfolni nem sikerült.', ZK)
    t(PROOF_UNKNOWN, DE, 'Die Aussage wurde weder bewiesen noch widerlegt können.', ZK)
    t(STATEMENT_ALWAYS_TRUE, EN, 'The statement is always true.', ZK)
    t(STATEMENT_ALWAYS_TRUE, HU, 'Az állítás mindig igaz.', ZK)
    t(STATEMENT_ALWAYS_TRUE, DE, 'Die Aussage ist immer wahr.', ZK)
    t(TRUE_ON_PARTS, EN, 'The statement is true on parts, false on parts.', ZK)
    t(TRUE_ON_PARTS, HU, 'Az állítás részben igaz, részben hamis.', ZK)
    t(TRUE_ON_PARTS, DE, 'Die Aussage ist teilweise wahr und teilweise falsch.', ZK)
    t(TRUE_UNDER_NONDEGENERACY_CONDITIONS, EN, 'The statement is true under some non-degeneracy conditions (see below).', ZK)
    t(TRUE_UNDER_NONDEGENERACY_CONDITIONS, HU, 'Az állítás igaz, ha a szerkesztés nem elfajuló (lásd lejjebb).', ZK)
    t(TRUE_UNDER_NONDEGENERACY_CONDITIONS, DE, 'Die Aussage ist wahr, falls die Konstruktion nicht entartet ist (siehe unten).', ZK)
    t(STATEMENT_FALSE, EN, 'The statement is false.', ZK)
    t(STATEMENT_FALSE, HU, 'Az állítás hamis.', ZK)
    t(STATEMENT_FALSE, DE, 'Die Aussage ist falsch.', ZK)
    t(STATEMENT_TRIVIAL, EN, 'The statement is trivial.', ZK)
    t(STATEMENT_TRIVIAL, HU, 'Az állítás triviális.', ZK)
    t(STATEMENT_TRIVIAL, DE, 'Die Aussage ist trivial.', ZK)
    t(PROVE_BY_CONTRADICTION, EN, 'We prove this by contradiction.', ZK)
    t(PROVE_BY_CONTRADICTION, HU, 'Indirekt bizonyítást adunk.', ZK)
    t(PROVE_BY_CONTRADICTION, DE, 'Ein Indirektbeweis wird gezeigt.', ZK)
    t(NO_FULL_PROOF, EN, 'Currently no full proof can be provided, but just some steps.', ZK)
    t(NO_FULL_PROOF, HU, 'Jelenleg nem áll rendelkezésre teljes bizonyítás, csak néhány lépés.', ZK)
    t(NO_FULL_PROOF, DE, 'Momentan steht kein vollständiger Beweis zur Verfügung, nur manche Schritte.', ZK)
    t(NO_FULL_PRESENTATION, EN, 'In the background, all steps are checked, but a full presentation is not yet implemented.', ZK)
    t(NO_FULL_PRESENTATION, HU, 'A háttérben minden lépés ellenőrzésre került, de ezek ismertetése még nincs leprogramozva.', ZK)
    t(NO_FULL_PRESENTATION, DE, 'Im Hintergrund wurden alle Schritte überprüft, eine vollständige Präsentation ist aber nicht implementiert.', ZK)
    t(TRY_NEWER_VERSION, EN, 'Please try a newer version of GeoGebra Discovery if possible.', ZK)
    t(TRY_NEWER_VERSION, HU, 'Lehet, hogy a program egy újabb verziójában ez a funkció már rendelkezésre áll.', ZK)
    t(TRY_NEWER_VERSION, DE, 'Versuchen Sie eine neuere Version von GeoGebra Discovery zu verwenden, falls möglich.', ZK)
    t(UNSUPPORTED_AXES_FIXED_SLOPE_LINES, EN, 'Statements containing axes or fixed slope lines are unsupported.', ZK)
    t(UNSUPPORTED_AXES_FIXED_SLOPE_LINES, HU, 'Tengelyeket és rögzített meredekségű egyeneseket tartalmazó állítások nem támogatottak.', ZK)
    t(UNSUPPORTED_AXES_FIXED_SLOPE_LINES, DE, 'Aussagen über Achsen oder Geraden mit fixierten Steigung sind nicht unterstützt.', ZK)
    t(CONSIDERING_DEFINITION_A, EN, 'Considering definition %0:', ZK)
    t(CONSIDERING_DEFINITION_A, HU, 'A(z) %0 definíciót figyelembe véve:', ZK)
    t(CONSIDERING_DEFINITION_A, DE, 'Laut Definition %0:', ZK)
    t(LET_FREE_POINT_A_DENOTED_BY_B, EN, 'Let free point %0 be denoted by %1.', ZK)
    t(LET_FREE_POINT_A_DENOTED_BY_B, HU, 'Jelöljük a(z) %0 szabad pontot %1-val/-vel.', ZK)
    t(LET_FREE_POINT_A_DENOTED_BY_B, DE, 'Sei freier Punkt %0 mit %1 beschriftet.', ZK)
    t(ONLY_FIRST_FIXED_BECAUSE_A_ON_B, EN, 'Only the first free point can be fixed, because %0 is on linear path %1.', ZK)
    t(ONLY_FIRST_FIXED_BECAUSE_A_ON_B, HU, 'Csak az első pont rögzíthető, mert %0 a(z) %1 egyenesen van.', ZK)
    t(ONLY_FIRST_FIXED_BECAUSE_A_ON_B, DE, 'Nur der erste Punkt kann fixiert werden, weil %0 auf der Geraden %1 liegt.', ZK)
    t(LET_DEPENDENT_POINT_A_DENOTED_BY_B, EN, 'Let dependent point %0 be denoted by %1.', ZK)
    t(LET_DEPENDENT_POINT_A_DENOTED_BY_B, HU, 'Jelöljük a(z) %0 függő pontot %1-val/-vel.', ZK)
    t(LET_DEPENDENT_POINT_A_DENOTED_BY_B, DE, 'Beschriften wir den abhängigen Punkt %0 mit %1.', ZK)
    t(OBJECT_A_INTRODUCES, EN, 'Object %0 introduces the following extra variables:', ZK)
    t(OBJECT_A_INTRODUCES, HU, 'A(z) %0 objektumhoz a következő további változókra lesz szükség:', ZK)
    t(OBJECT_A_INTRODUCES, DE, 'Fürs Objekt %0 sind folgende Variablen notwendig:', ZK)
    t(COMMAND_A_NOT_FULLY_IMPLEMENTED, EN, 'Command %0 is not fully implemented in the prover.', ZK)
    t(COMMAND_A_NOT_FULLY_IMPLEMENTED, HU, 'A(z) %0 parancs nem áll teljesen rendelkezésre a bizonyító alrendszerben.', ZK)
    t(COMMAND_A_NOT_FULLY_IMPLEMENTED, DE, 'Befehl %0 ist nicht vollständig unterstützt.', ZK)
    t(COMMAND_A_NOT_IMPLEMENTED, EN, 'Command %0 is not implemented in the prover.', ZK)
    t(COMMAND_A_NOT_IMPLEMENTED, HU, 'A(z) %0 parancs nem áll rendelkezésre a bizonyító alrendszerben.', ZK)
    t(COMMAND_A_NOT_IMPLEMENTED, DE, 'Befehl %0 ist nicht unterstützt.', ZK)
    t(THESIS_EQS_NON_DENIED, EN, 'Thesis equations (non-denied ones):', ZK)
    t(THESIS_EQS_NON_DENIED, HU, 'A következmény egyenletei (az állító formájúak):', ZK)
    t(THESIS_EQS_NON_DENIED, DE, 'Die Gleichungen der Konsequenz (die nicht negiert sind):', ZK)
    t(THESIS_EQ_DENIED, EN, 'Thesis reductio ad absurdum (denied statement):', ZK)
    t(THESIS_EQ_DENIED, HU, 'A következmény tagadása:', ZK)
    t(THESIS_EQ_DENIED, DE, 'Die Verneinung der Konsequenz:', ZK)
    t(DUMMY_VAR_NEG, EN, 'dummy variable to express negation', ZK)
    t(DUMMY_VAR_NEG, HU, 'extra változó a tagadáshoz', ZK)
    t(DUMMY_VAR_NEG, DE, 'extra Variable für die Verneinung', ZK)
    t(STATEMENT_A_NOT_FULLY_IMPLEMENTED, EN, 'Statement %0 is not fully implemented in the prover.', ZK)
    t(STATEMENT_A_NOT_FULLY_IMPLEMENTED, HU, 'A(z) %0 állítás nem áll teljesen rendelkezésre a bizonyító alrendszerben.', ZK)
    t(STATEMENT_A_NOT_IMPLEMENTED, EN, 'Statement %0 is not implemented in the prover.', ZK)
    t(STATEMENT_A_NOT_IMPLEMENTED, HU, 'A(z) %0 állítás nem áll rendelkezésre a bizonyító alrendszerben.', ZK)
    t(STATEMENT_A_NOT_IMPLEMENTED, DE, 'Aussage %0 ist nicht vollständig unterstützt.', ZK)
    t(WLOG_COORDINATES, EN, 'Without loss of generality, some coordinates can be fixed:', ZK)
    t(WLOG_COORDINATES, HU, 'Az általánosság megszorítása nélkül néhány koordináta rögzíthető:', ZK)
    t(WLOG_COORDINATES, DE, 'Ohne Beschränkung der Allgemeinheit können manche Koordinaten fixiert werden:', ZK)
    t(CANNOT_DECIDE_ALGEBRAIC_DIFFICULTIES, EN, 'Sorry, the program cannot decide due to algebraic difficulties.', ZK)
    t(CANNOT_DECIDE_ALGEBRAIC_DIFFICULTIES, HU, 'Sajnos, algebrai okok miatt a program képtelen eldönteni.', ZK)
    t(CANNOT_DECIDE_ALGEBRAIC_DIFFICULTIES, DE, 'Leider kann das Programm aus algebraischen Gründen keine Entscheidung treffen.', ZK)
    t(WEAKENING_TRUE, EN, 'A weakening of the statement is true.', ZK)
    t(WEAKENING_TRUE, HU, 'Egy gyengített állítás igaz.', ZK)
    t(WEAKENING_TRUE, DE, 'Eine abgeschwächte Aussage ist wahr.', ZK)
    t(STATEMENT_TRUE_NDG, EN, 'The statement can be suspected to be true under some non-degeneracy conditions:', ZK)
    t(STATEMENT_TRUE_NDG, HU, 'Az állítás a következő nem-elfajuló feltételek esetén lesz igaz:', ZK)
    t(STATEMENT_TRUE_NDG, DE, 'Die Aussage ist wahr unter folgenden nicht-entarteten Bedingungen:', ZK)
    t(AFTER_SUBS, EN, 'After substitutions:', ZK)
    t(AFTER_SUBS, HU, 'Behelyettesítés után:', ZK)
    t(AFTER_SUBS, DE, 'Nach Einsetzen:', ZK)
    t(STATEMENT_TRUE_NDG_UNREADABLE, EN, 'The statement is true under some non-degeneracy conditions (they cannot be expressed in simple geometric terms):', ZK)
    t(STATEMENT_TRUE_NDG_UNREADABLE, HU, 'Az állítás bizonyos nem-elfajuló feltételek esetén lesz igaz (melyek nem adhatók meg egyszerű geometriai formában):', ZK)
    t(STATEMENT_TRUE_NDG_UNREADABLE, DE, 'Die Aussage ist wahr unter bestimmten nicht-entarteten Bedingungen (die in keiner einfachen Form ausgedrückt werden können):', ZK)
    t(ALL_HYPOS_NEG_THESIS, EN, 'All hypotheses and the negated thesis after substitutions:', ZK)
    t(ALL_HYPOS_NEG_THESIS, HU, 'Az előfeltételek és tagadott következmény behelyettesítés után:', ZK)
    t(ALL_HYPOS_NEG_THESIS, DE, 'Alle Bedingungen und die negierte Konsequenz nach Einsetzen:', ZK)
    t(NOW_CONSIDER, EN, 'Now we consider the following equation:', ZK)
    t(NOW_CONSIDER, HU, 'Most tekintsük a következő egyenletet:', ZK)
    t(NOW_CONSIDER, DE, 'Nun betrachten wir folgende Gleichung:', ZK)
    t(CONTRADICTION_THIS_PROVES, EN, 'Contradiction! This proves the original statement.', ZK)
    t(CONTRADICTION_THIS_PROVES, HU, 'Ellentmondás! Ezáltal az eredeti állítást igazoltuk.', ZK)
    t(CONTRADICTION_THIS_PROVES, DE, 'Widerspruch! So wurde die ursprüngliche Aussage bewiesen.', ZK)
    t(DIFFICULTY_A, EN, 'The statement has a difficulty of degree %0.', ZK)
    t(DIFFICULTY_A, HU, 'Az állítás nehézségi foka: %0.', ZK)
    t(DIFFICULTY_A, DE, 'Der Schwierigkeitsgrad der Aussage ist %0.', ZK)
    t(PROOF_PREPARATION_SEEMS_DIFFICULT, EN, 'The preparation of the proof seems computationally too difficult, sorry.', ZK)
    t(PROOF_PREPARATION_SEEMS_DIFFICULT, HU, 'A bizonyítás lépéseinek előkészítése sajnos túl számításigényes.', ZK)
    t(PROOF_PREPARATION_SEEMS_DIFFICULT, DE, 'Leider ist die Vorbereitung der Beweisschritte zu kompliziert.', ZK)
    t(FORCING_NON_COLLINEARITY, EN, 'Forcing non-collinearity for certain point triplets:', ZK)
    t(FORCING_NON_COLLINEARITY, HU, 'Bizonyos háromszögek nem lehetnek elfajulóak:', ZK)
    t(FORCING_NON_COLLINEARITY, DE, 'Manche Dreiecke dürfen nicht entartet sein:', ZK)
    t(THESIS_A_IN_ALGEBRAIC_FORM, EN, 'Thesis: %0, in algebraic form:', ZK)
    t(THESIS_A_IN_ALGEBRAIC_FORM, DE, 'Konsequenz: %0, in algebraischer Form:', ZK)
    t(THESIS_A_IN_ALGEBRAIC_FORM, HU, 'Következmény: %0, algebrai formában:', ZK)
    t(STATEMENT_REQUIRES_CONDITIONS, EN, 'The statement requires some conditions:', ZK)
    t(STATEMENT_REQUIRES_CONDITIONS, DE, 'Die Aussage benötigt bestimmte Voraussetzungen:', ZK)
    t(STATEMENT_REQUIRES_CONDITIONS, HU, 'Az állítás bizonyos feltételek mellett érvényes:', ZK)

    t(ONLY_FIRST_FIXED_EXPRESSION, EN, 'Only the first free point can be fixed, because the thesis is an expression.', ZK)
    t(ONLY_FIRST_FIXED_EXPRESSION, HU, 'Csak az első pont rögzíthető, mert a bizonyítandó állítás egy kifejezés.', ZK)
    t(ONLY_FIRST_FIXED_EXPRESSION, DE, 'Nur der erste Punkt kann fixiert werden, weil die Konsequenz ein Ausdruck ist.', ZK)
    t(A_VALUE_OF_CENTER_OF_B, EN, '%0 value of center of %1', ZK)
    t(A_VALUE_OF_CENTER_OF_B, HU, '%1 középpontjának %0-koordinátája', ZK)
    t(A_VALUE_OF_CENTER_OF_B, DE, '%0-Koordinate des Mittelpunktes von %1', ZK)
    t(A_VALUE_OF_A_POINT_OF_B, EN, '%0 value of a point of %1', ZK)
    t(A_VALUE_OF_A_POINT_OF_B, DE, '%0-Koordinate eines Punktes von %1', ZK)
    t(A_VALUE_OF_A_POINT_OF_B, HU, '%1 egy pontjának %0-koordinátája', ZK)
    t(A_VALUE_OF_AN_IMPLICITLY_INTRODUCED_SECOND_POINT_FOR_ORTHOGONAL_LINE_AT_B_TO_C, EN, '%0 value of an implicitly introduced second point for orthogonal line at %1 to %2', ZK)
    t(A_VALUE_OF_AN_IMPLICITLY_INTRODUCED_SECOND_POINT_FOR_ORTHOGONAL_LINE_AT_B_TO_C, DE, '%0-Koordinate eines implizit eingeführten zweiten Punktes für senkrechte Gerade an %1 auf %2', ZK)
    t(A_VALUE_OF_AN_IMPLICITLY_INTRODUCED_SECOND_POINT_FOR_ORTHOGONAL_LINE_AT_B_TO_C, HU, 'A(z) %1-ban/-ben %2-ra/-re merőlegesen állított egyenes másik pontjának %0-koordinátája', ZK)
    t(A_VALUE_OF_MIDPOINT_OF_B, EN, '%0 value of midpoint of %1', ZK)
    t(A_VALUE_OF_MIDPOINT_OF_B, DE, '%0-Koordinate des Mittelpunkts von %1', ZK)
    t(A_VALUE_OF_MIDPOINT_OF_B, HU, '%1 felezőpontjának %0-koordinátája', ZK)
    t(A_VALUE_OF_ROTATION_OF_POINT_B_AROUND_THE_MIDPOINT_OF_C_BY_D_DEGREES, EN, '%0 value of rotation of point %1 around the midpoint of %2 by %3 degrees', ZK)
    t(A_VALUE_OF_ROTATION_OF_POINT_B_AROUND_THE_MIDPOINT_OF_C_BY_D_DEGREES, DE, '%0-Koordinate der Drehung des Punktes %1 um Mittelpunkt von %2 um %3 Grad', ZK)
    t(A_VALUE_OF_ROTATION_OF_POINT_B_AROUND_THE_MIDPOINT_OF_C_BY_D_DEGREES, HU, '%1 %0-koordinátája, miután %2 felezőpontja körül %3 fokkal elforgattuk', ZK)
    t(A_VALUE_OF_MIDPOINT_OF_RHOMBUS_ANGULAR_BISECTOR_B, EN, '%0 value of midpoint of the rhombus (which the angular bisector %1 will pass through)', ZK) # DE, ...
    t(A_VALUE_OF_MIDPOINT_OF_RHOMBUS_ANGULAR_BISECTOR_B, HU, 'Azon rombusz középpontjának %0-koordinátája, amely a(z) %1 szögfelezőre illeszkedik', ZK)
    t(A_VALUE_OF_HELPER_POINT_MIRROR_B_C_ABOUT_D_E, EN, '%0 value of the helper point that is a mirror of (%1,%2) about (%3,%4)', ZK) # DE, ...
    t(A_VALUE_OF_HELPER_POINT_MIRROR_B_C_ABOUT_D_E, HU, 'Egy segédpont %0-koordinátája, amely (%1,%2)-nak/-nek (%3,%4)-ra/-re vonatkozó tükörképe', ZK)

    t(VARIABLE_A_IS_ALREADY_DEFINED_PLEASE_REMOVE_IT_FIRST, EN, 'Variable %0 is already defined. Please remove it first.', ZK)
    t(VARIABLE_A_IS_ALREADY_DEFINED_PLEASE_REMOVE_IT_FIRST, DE, 'Variable %0 wurde bereits definiert. Sie muss erst gelöscht werden.', ZK)
    t(VARIABLE_A_IS_ALREADY_DEFINED_PLEASE_REMOVE_IT_FIRST, HU, 'A(z) %0 változó már létezik. Először törölni kell.', ZK)
    t(PLEASE_OPEN_THE_CAS_VIEW_FIRST, EN, 'Please open the CAS View first.', ZK)
    t(PLEASE_OPEN_THE_CAS_VIEW_FIRST, DE, 'Bitte öffne die CAS-Ansicht zunächst.', ZK)
    t(PLEASE_OPEN_THE_CAS_VIEW_FIRST, HU, 'Nyisd meg előbb a CAS - komputeralgebra ablakot!', ZK)
    t(PROVER_TIMEOUT, EN, 'The prover subsystem has timed out, sorry.', ZK)
    t(PROVER_TIMEOUT, DE, 'Leider ist beim Prüfer-Subsystem eine Zeitüberschreitung aufgetreten.', ZK)
    t(PROVER_TIMEOUT, HU, 'A bizonyító alrendszerben időtúllépés történt.', ZK)
    t(GEOGEBRA_CANNOT_CHECK, EN, 'GeoGebra cannot check that this is equivalent to 1=0, but it can be calculated in another computer algebra system.', ZK)
    t(GEOGEBRA_CANNOT_CHECK, HU, 'A GeoGebra nem tudja ellenőrizni, hogy ez az 1=0-val ekvivalens, de más komputeralgebra szoftver képes rá.', ZK)
    t(GEOGEBRA_CANNOT_CHECK, DE, 'GeoGebra kann nicht überprüfen, dass dies äquivalent zu 1=0 ist, aber es kann in einem anderen Computeralgebrasystem berechnet werden.', ZK)
    #
    t(SHOWPROOF, ES, 'VerDemo', TR)
    t(SHOWPROOF_SYNTAX, ES, '[ <Expresión Booleana> ]', TR)
    t(PROVE_THAT_A, ES, 'Demuestra que %0.', TR)
    t(LET_A_BE_ARBITRARY_POINTS, ES, 'Sean %0 puntos arbitrarios.', TR)
    t(LET_A_BE_AN_ARBITRARY_POINT, ES, 'Sea %0 un punto arbitrario.', TR)
    t(LET_A_BE_THE_B, ES, 'Sea %0: %1.', TR)
    t(LET_A_BE_A_B, ES, 'Sea %0: %1.', TR)
    t(LET_A_BE_THE_REGULAR_POLYGON_BCD, ES, 'Sea %0 el %3-gono regular sobre el segmento %1, %2.', TR)
    t(LET_A_BE_THE_REGULAR_BGON_VERTICES_C, ES, 'Sea %0 el %1-gono con vértices %2.', TR)
    t(DENOTE_THE_EXPRESSION_A_BY_B, ES, 'Denotemos la expresión %0 como %1.', TR)
    t(PROOF_UNKNOWN, ES, 'La verdad de la proposición no ha podido ser comprobada ni negada.', TR)
    t(STATEMENT_ALWAYS_TRUE, ES, 'La proposición es siempre verdad.', TR)
    t(TRUE_ON_PARTS, ES, 'La proposición es parcialmente verdad, parcialmente falsa.', TR)
    t(TRUE_UNDER_NONDEGENERACY_CONDITIONS, ES, 'La proposición es verdad bajo ciertas condiciones de no degeneración (véase abajo).', TR)
    t(STATEMENT_FALSE, ES, 'La proposición es falsa.', TR)
    t(STATEMENT_TRIVIAL, ES, 'La proposición es trivial.', TR)
    t(PROVE_BY_CONTRADICTION, ES, 'Demostremos esto por contradicción.', TR)
    t(NO_FULL_PROOF, ES, 'Actualmente no podemos proporcionar una demostración completa, sólo algunos pasos.', TR)
    t(NO_FULL_PRESENTATION, ES, 'Internamente todos los pasos han sido verificados, pero una visualización completa de los mismos aún no está implementada.', TR)
    t(TRY_NEWER_VERSION, ES, 'Por favor, si es posible, intente usar una nueva versión de GeoGebra Discovery', TR)
    t(UNSUPPORTED_AXES_FIXED_SLOPE_LINES, ES, 'No se consideran  aquellas proposiciones que incluyen ejes o rectas de pendiente fija.', TR)
    t(CONSIDERING_DEFINITION_A, ES, 'Teniendo en cuenta la definición %0:', TR)
    t(LET_FREE_POINT_A_DENOTED_BY_B, ES, 'Denotemos el punto libre %0 como %1.', TR)
    t(ONLY_FIRST_FIXED_BECAUSE_A_ON_B, ES, 'Sólo es posible fijar el primer punto libre, porque %0 está en la línea %1.', TR)
    t(LET_DEPENDENT_POINT_A_DENOTED_BY_B, ES, 'Denotemos el punto dependiente %0 como %1.', TR)
    t(OBJECT_A_INTRODUCES, ES, 'El objeto %0 introduce las siguientes variables extra:', TR)
    t(COMMAND_A_NOT_FULLY_IMPLEMENTED, ES, 'El comando %0 no está totalmente implementado en el demostrador.', TR)
    t(COMMAND_A_NOT_IMPLEMENTED, ES, 'El comando %0 no está implementado en el demostrador.', TR)
    t(THESIS_EQS_NON_DENIED, ES, 'Ecuaciones (afirmativas) de la tesis:', TR)
    t(THESIS_EQ_DENIED, ES, 'Tesis por reducción al absurdo (negación de la proposición):', TR)
    t(DUMMY_VAR_NEG, ES, 'varible muda para expresar negación', TR)
    t(STATEMENT_A_NOT_FULLY_IMPLEMENTED, ES, 'La proposición %0 no está totalmente implementada en el demostrador.', TR)
    t(STATEMENT_A_NOT_IMPLEMENTED, ES, 'La proposición %0 no está implementada en el demostrador.', TR)
    t(WLOG_COORDINATES, ES, 'Sin pérdida de generalidad podemos fijar algunas coordenadas:', TR)
    t(CANNOT_DECIDE_ALGEBRAIC_DIFFICULTIES, ES, 'Perdón, el programa no puede concluir nada por ciertas dificultades algebraicas.', TR)
    t(WEAKENING_TRUE, ES, 'Una afirmación más débil es cierta.', TR)
    t(STATEMENT_TRUE_NDG, ES, 'La proposición parece ser cierta bajo ciertas condiciones de no degeneración:', TR)
    t(AFTER_SUBS, ES, 'Tras las sustituciones:', TR)
    t(STATEMENT_TRUE_NDG_UNREADABLE, ES, 'La proposición es cierta bajo ciertas condiciones de no degeneración (que no pueden expresarse en términos geométricos simples):', TR)
    t(ALL_HYPOS_NEG_THESIS, ES, 'Todas las hipótesis, y la negación de la tesis, tras las sustituciones:', TR)
    t(NOW_CONSIDER, ES, 'Consideremos ahora la siguiente ecuación:', TR)
    t(CONTRADICTION_THIS_PROVES, ES, 'Contradicción! Lo que prueba la proposición original.', TR)
    t(DIFFICULTY_A, ES, 'La proposición tiene dificultad de grado %0.', TR)
    t(PROOF_PREPARATION_SEEMS_DIFFICULT, ES, 'Perdón, la preparación de la demostración parece ser, computacionalmente, demasiado difícil.', TR)
    t(FORCING_NON_COLLINEARITY, ES, 'Forzar la no colinealidad para determinadas tripletas de puntos.', ZK)
    t(ONLY_FIRST_FIXED_EXPRESSION, ES, 'Sólo se puede fijar el primer punto libre, porque la tesis es una expresión.', ZK)
    t(A_VALUE_OF_AN_IMPLICITLY_INTRODUCED_SECOND_POINT_FOR_ORTHOGONAL_LINE_AT_B_TO_C, ES, 'La coordenada %0 del punto secundo implicitamente introducido de la recta ortogonal a %2 por %1', TR)
    t(A_VALUE_OF_MIDPOINT_OF_B, ES, 'La coordenada %0 del punto medio de %1', TR)
    t(A_VALUE_OF_ROTATION_OF_POINT_B_AROUND_THE_MIDPOINT_OF_C_BY_D_DEGREES, ES, 'La coordenada %0 del punto resultante del giro de %3 grados del punto %1 alrededor del punto medio de %2', TR)
    t(THESIS_A_IN_ALGEBRAIC_FORM, ES, 'Tesis: %0, en forma algebraica:', TR)
    t(PROVER_TIMEOUT, ES, 'El subsistema de demostración se ha quedado sin tiempo, lo siento.', TR)
    t(GEOGEBRA_CANNOT_CHECK, ES, 'GeoGebra no puede verificar que esto es equivalente a 1=0, pero podría realizarse este cálculo en otro sistema de algebra computacional.', TR)
    #
    t(SHOWPROOF, FR, 'AfficherPreuve', BP)
    # t(SHOWPROOF_SYNTAX, FR, '[ <Expression booléeenne> ]', BP)
    t(PROVE_THAT_A, FR, 'Montrons %0.', BP)
    t(LET_A_BE_ARBITRARY_POINTS, FR, 'Soit %0 des points arbitraires.', BP)
    t(LET_A_BE_THE_B, FR, 'Soit %0 le/la %1.', BP)
    t(LET_A_BE_A_B, FR, 'Soit %0 un/une %1.', BP)
    t(LET_A_BE_THE_REGULAR_POLYGON_BCD, FR, 'Soit %0 le polygone régulier %3 sur le segment %1, %2.', BP)
    t(LET_A_BE_THE_REGULAR_BGON_VERTICES_C, FR, 'Soit %0 le polygone régulier %1 ayant pour sommets %2.', BP)
    t(DENOTE_THE_EXPRESSION_A_BY_B, FR, 'Notons %1 l\'expression %0.', BP)
    t(PROOF_UNKNOWN, FR, 'L\'énoncé n\'a pas pu être prouvé ni réfuté.', BP)
    t(STATEMENT_ALWAYS_TRUE, FR, 'L\'énoncé est toujours vrai.', BP)
    t(TRUE_ON_PARTS, FR, 'L\'énoncé est vrai sur certaines parties, faux sur d\'autres.', BP)
    t(TRUE_UNDER_NONDEGENERACY_CONDITIONS, FR, 'Certaines parties de l\'énoncé sont vraies, d\'autres fausses.', BP)
    t(STATEMENT_FALSE, FR, 'L\'énoncé est faux.', BP)
    t(STATEMENT_TRIVIAL, FR, 'L\'énoncé est trivial.', BP)
    t(PROVE_BY_CONTRADICTION, FR, 'Preuve par l\'absurde.', BP)
    t(NO_FULL_PROOF, FR, 'Certaines étapes sont prouvées, mais le logiciel n\'est pas capable pour le moment de prouver l\'énoncé au complet.', BP)
    t(NO_FULL_PRESENTATION, FR, 'En arrière-plan, toutes les étapes sont vérifiées, mais une présentation complète n\'est pas encore implémentée.', BP)
    t(TRY_NEWER_VERSION, FR, 'Veuillez essayer une version plus récente de GeoGebra Discovery si possible.', BP)
    t(UNSUPPORTED_AXES_FIXED_SLOPE_LINES, FR, 'Les énoncés contenant des axes ou des droites de pente fixée par l\'utilisateur ne sont pas pris en charge.', BP)
    t(CONSIDERING_DEFINITION_A, FR, 'En considérant la définition %0 :', BP)
    t(LET_FREE_POINT_A_DENOTED_BY_B, FR, 'Notons %1 le point libre %0.', BP)
    t(ONLY_FIRST_FIXED_BECAUSE_A_ON_B, FR, 'Seul le premier point libre peut être fixé, car %0 est sur la droite %1.', BP)
    t(LET_DEPENDENT_POINT_A_DENOTED_BY_B, FR, 'Notons %1 le point dépendant %0.', BP)
    t(OBJECT_A_INTRODUCES, FR, 'L\'objet %0 introduit les variables supplémentaires suivantes :', BP)
    t(COMMAND_A_NOT_FULLY_IMPLEMENTED, FR, 'La commande %0 n\'est pas entièrement implémentée dans l\'assistant logiciel de preuve.', BP)
    t(COMMAND_A_NOT_IMPLEMENTED, FR, 'La commande %0 n\'est pas implémentée dans l\'assistant logiciel de preuve.', BP)
    t(THESIS_EQS_NON_DENIED, FR, 'Equations des assertions (celles dont on ne prend pas la négation) :', BP)
    t(THESIS_EQ_DENIED, FR, 'Négation de l\'assertion menant à une contradiction :', BP)
    t(DUMMY_VAR_NEG, FR, 'variable factice pour exprimer la négation', BP)
    t(STATEMENT_A_NOT_FULLY_IMPLEMENTED, FR, 'L\'énoncé %0 n\'est pas entièrement implémenté dans l\'assistant logiciel de preuve.', BP)
    t(STATEMENT_A_NOT_IMPLEMENTED, FR, 'L\'énoncé %0 n\'est pas implémenté dans l\'assistant logiciel de preuve.', BP)
    t(WLOG_COORDINATES, FR, 'Sans perte de généralité, certaines coordonnées peuvent être fixées :', BP)
    t(CANNOT_DECIDE_ALGEBRAIC_DIFFICULTIES, FR, 'Désolé, le programme ne peut pas décider en raison de la complexité des calculs.', BP)
    t(WEAKENING_TRUE, FR, 'Une version faible de l\'énoncé est vraie', BP)
    t(STATEMENT_TRUE_NDG, FR, 'L\'énoncé est probablement vrai sous certaines conditions de non-dégénérescence :', BP)
    t(AFTER_SUBS, FR, 'Après substitutions :', BP)
    t(STATEMENT_TRUE_NDG_UNREADABLE, FR, 'L\'énoncé est vrai sous certaines conditions de non-dégénérescence (elles ne peuvent pas être exprimées en termes géométriques simples) :', BP)
    t(ALL_HYPOS_NEG_THESIS, FR, 'Les hypothèses et la négation de l\'assertion, après substitutions :', BP)
    t(NOW_CONSIDER, FR, 'Maintenant, nous considérons l\'équation suivante :', BP)
    t(CONTRADICTION_THIS_PROVES, FR, 'Contradiction ! Cela prouve l\'énoncé original.', BP)
    t(DIFFICULTY_A, FR, 'On associe à l\'énoncé un polynôme de degré %0', BP)
    t(PROOF_PREPARATION_SEEMS_DIFFICULT, FR, 'La préparation de la preuve semble trop difficile à calculer, désolé.', BP)
    t(FORCING_NON_COLLINEARITY, FR, 'Forcer la non-colinéarité.', BP)
    t(THESIS_A_IN_ALGEBRAIC_FORM, FR, 'Assertion : %0 sous forme algébrique', ZK)
    t(ONLY_FIRST_FIXED_EXPRESSION, FR, 'Seul le premier point libre peut être fixé, car l\'assertion est une expression.', BP)
    t(A_VALUE_OF_CENTER_OF_B, FR, '%0 valeur du centre de %1', ZK)
    t(A_VALUE_OF_A_POINT_OF_B, FR, '%0 valeur d\'un point de %1', ZK)
    t(A_VALUE_OF_AN_IMPLICITLY_INTRODUCED_SECOND_POINT_FOR_ORTHOGONAL_LINE_AT_B_TO_C, FR, '%0 valeur du deuxième point de la droite orthogonale en %1 à %2 (introduit implicitement)', BP)
    t(A_VALUE_OF_MIDPOINT_OF_B, FR, '%0 valeur du milieu de %1', ZK)
    t(A_VALUE_OF_ROTATION_OF_POINT_B_AROUND_THE_MIDPOINT_OF_C_BY_D_DEGREES, FR, '%0 valeur de l\'image du point %1 par la rotation de centre le milieu de %2 et d\'angle %3 degrés', BP)
    t(VARIABLE_A_IS_ALREADY_DEFINED_PLEASE_REMOVE_IT_FIRST, FR, 'La variable %0 est déjà définie. Veuillez d\'abord la supprimer.', ZK)
    t(PLEASE_OPEN_THE_CAS_VIEW_FIRST, FR, 'Veuillez ouvrir d\'abord la vue CAS.', ZK)

    t(DISCOVER, FR, 'Découvrir', NL)
    t(DISCOVER_TOOL, FR, 'Découvrir', NL)
    t(DISCOVER_TOOL_HELP, FR, 'Sélectionner un point', NL)
    t(DISCOVERED_THEOREMS_ON_POINT, FR, 'Théorèmes découverts pour le point %0', NL)
    t(DISCOVER_SYNTAX, FR, '[ <Point> ]', NL)
    t(NO_THEOREMS_FOUND, FR, 'Pas de théorèmes trouvés', NL)
    t(REDRAW_DIFFERENTLY, FR, 'Essayer de réaliser différemment la construction.', NL)
    t(UNSUPPORTED_STEPS, FR, 'La construction contient des étapes non supportées.', NL)
    t(IDENTICAL_POINTS_A, FR, 'Points confondus : %0', NL)
    t(COLLINEAR_POINTS_A, FR, 'Points alignés : %0', NL)
    t(CONCYCLIC_POINTS_A, FR, ' Points cocycliques : %0', NL)
    t(CONGRUENT_SEGMENTS_A, FR, 'Segments isométriques : %0', NL)
    t(SETS_OF_PARALLEL_AND_PERPENDICULAR_LINES_A, FR, 'Droites parallèles ou perpendiculaires : %0', NL)
    t(IN_PROGRESS, FR, 'En cours', NL)
    t(CANNOT_DECIDE_EQUALITY_OF_POINTS_A_B, FR, 'Impossible de décider de l\'égalité des points  %0 et %1.', NL)
    t(COMPARE, FR, 'Comparer', NL)
    t(COMPARE_SYNTAX, FR, '[ <Expression>, <Expression> ]', NL)
    t(COMPARE_A_AND_B, FR, 'Comparer %0 et %1.', NL)
    t(INCIRCLECENTER, FR, 'CentreCercleInscrit', NL)
    t(INCIRCLECENTER_SYNTAX, FR, '[ <Point>, <Point>, <Point> ]', NL)
    t(INCIRCLECENTER_TOOL, FR, 'Centre du cercle inscrit', NL)
    t(INCIRCLECENTER_TOOL_HELP, FR, 'Sélectionner trois points', NL)
    t(INCIRCLE_TOOL, FR, 'Cercle inscrit', NL)
    t(INCIRCLE_TOOL_HELP, FR, 'Sélectionner trois points', NL)
    t(LOCUSEQUATION_TOOL, FR, 'Equation Lieu', NL)
    t(LOCUSEQUATION_TOOL_HELP, FR, 'Sélectionner point décrivant lieu, puis point sur objet', NL)
    t(ENVELOPE_TOOL, FR, 'Enveloppe', NL)
    t(ENVELOPE_TOOL_HELP, FR, 'Sélectionner chemin, puis point sur objet', NL)
    t(STATEMENT_REQUIRES_CONDITIONS, FR, 'L\’énoncé nécessite certaines conditions:', NL)
    t(A_VALUE_OF_MIDPOINT_OF_RHOMBUS_ANGULAR_BISECTOR_B, FR, '%0 valeur du centre du losange (par lequel passera la bissectrice %1)', NL)
    t(A_VALUE_OF_HELPER_POINT_MIRROR_B_C_ABOUT_D_E, FR, '%0 valeur du point symétrique de (%1,%2) par rapport à (%3,%4)', NL)
    t(PROVER_TIMEOUT, FR, 'Le sous-système de preuve a expiré, désolé.', NL)
    t(GEOGEBRA_CANNOT_CHECK, FR, 'GeoGebra ne peut pas vérifier que cela est équivalent à 1=0, mais cela pourrait être calculé dans un autre CAS.', NL)
    t(REALQUANTIFIERELIMINATION, FR, 'ÉliminationQuantificateursRéels', NL)
    t(REALQUANTIFIERELIMINATION_SYNTAX, FR, '[ <Expression> ]', NL)
    t(STEPWISEDISCOVERY, FR, 'ÉtapesDécouverte', NL)
    t(STEPWISEDISCOVERY_SYNTAX, FR, "[ ]\n[ <Booléen> ]", NL)
    t(STEPWISEDISCOVERY_INFORMATION, FR, 'Information', NL)
    t(STEPWISEDISCOVERY_ENABLED, FR, 'La découverte par étapes est activée.', NL)
    t(STEPWISEDISCOVERY_DISABLED, FR, 'La découverte par étapes n\’est pas activée.', NL)
    t(STEPWISEDISCOVERY_STYLEBAR, FR, 'Bascule Découverte par étapes', NL)
    t(EXPORT_AS_LATEX, FR, 'Export en LaTeX', NL)
    t(CAS_MAPLE_TO_CLIPBOARD, FR, 'Vue CAS vers Maple via PressePapiers', NL)
    t(CAS_GIAC_TO_CLIPBOARD, FR, ' Vue CAS vers Giac via PressePapiers', NL)
    t(CLEAR_CAS_VIEW, FR, 'Effacer Vue CAS', NL)
    t(EXPORT_CAS_MAPLE, FR, 'Export Vue CAS vers Maple', NL)
    t(EXPORT_CAS_HTML, FR, 'Export Vue CAS en HTML', NL)
    t(EXPORT_CAS_LATEX, FR, 'Export Vue CAS vers LaTeX', NL)
    t(EXPORT_CAS_MATHEMATICA, FR, 'Export Vue CAS vers Mathematica', NL)
    t(EXPORT_CAS_GIAC, FR, 'Export Vue CAS vers Giac', NL)
    t(PLOT2D, FR, 'Graph2D', NL)
    t(PLOT2D_SYNTAX, FR, '[ <Fonction> ]', NL)
    t(SHOWPROOF_SYNTAX, FR, '[ <Booléen> ]', NL)
    #
    t(SHOWPROOF, HE, 'הצג הוכחה', ND)
    t(SHOWPROOF_SYNTAX, HE, '[ <ביטוי בוליאני> ]', ND)
    t(PROVE_THAT_A, HE, 'נוכיח כי %0.', ND)
    t(LET_A_BE_ARBITRARY_POINTS, HE, 'תהיינה %0 נקודות שרירותיות.', ND)
    t(LET_A_BE_THE_B, HE, '. נציב %0 במקום %1', ND)
    t(LET_A_BE_A_B, HE, 'תהי %0 אחד מ %1.', ND)
    t(LET_A_BE_THE_REGULAR_POLYGON_BCD, HE, 'יהי %0 המצולע המשוכלל %3 הבנוי על הקטע %1, %2.', ND)
    t(LET_A_BE_THE_REGULAR_BGON_VERTICES_C, HE, 'יהי %0 המצולע המשוכלל %1 עם קודקודים  %2.', ND)
    t(DENOTE_THE_EXPRESSION_A_BY_B, HE, 'נסמן את הביטוי %0 ב-%1.', ND)
    t(PROOF_UNKNOWN, HE, 'כרגע אי אפשר להוכיח או להפריך את הטענה.', ND)
    t(STATEMENT_ALWAYS_TRUE, HE, 'הטענה תמיד נכונה.', ND)
    t(TRUE_ON_PARTS, HE, 'הטענה נכונה בחלקים מסוימים ולא נכונה בחלקים אחרים.', ND)
    t(TRUE_UNDER_NONDEGENERACY_CONDITIONS, HE, 'חלקים של הטענה נכונים, חלקים אחרים לא.', ND)
    t(STATEMENT_FALSE, HE, 'הטענה שקרית.', ND)
    t(STATEMENT_TRIVIAL, HE, 'הטענה טריוויאלית.', ND)
    t(PROVE_BY_CONTRADICTION, HE, 'נהוכחה על דרך השלילה.', ND)
    t(NO_FULL_PROOF, HE, 'כרגע לא ניתן לספק הוכחה מלאה, אך רק כמה שלבים.', ND)
    t(NO_FULL_PRESENTATION, HE, 'ברקע, כל השלבים מאומתים, אך ההצגה המלאה עדיין לא מיושמת.', ND)
    t(TRY_NEWER_VERSION, HE, 'GeoGebra Discovery אם אפשר, נא לנסות גירסה חדשה יותר של', ND)
    t(UNSUPPORTED_AXES_FIXED_SLOPE_LINES, HE, 'הטענות המכילות צירים או קווים עם שפוע נתון לא נלקחות בחשבון.', ND)
    t(CONSIDERING_DEFINITION_A, HE, 'בהתייחס להגדרה %0:', ND)
    t(LET_FREE_POINT_A_DENOTED_BY_B, HE, 'נסמן ב %1 את הנקודה החופשית %0.', ND)
    t(ONLY_FIRST_FIXED_BECAUSE_A_ON_B, HE, 'רק הנקודה החופשית הראשונה יכולה להיות קבועה, מאחר ש-%0 נמצאת על הישר %1.', ND)
    t(LET_DEPENDENT_POINT_A_DENOTED_BY_B, HE, 'נסמן %1 את הנקודה התלויה %0.', ND)
    t(OBJECT_A_INTRODUCES, HE, 'האוביקט %0 מכניס את המשתנים הנוספים הבאים:', ND)
    t(COMMAND_A_NOT_FULLY_IMPLEMENTED, HE, 'הפקודה %0 אינה מוטמעת באופן מלא בתכנה התומכת בהוכחה.', ND)
    t(COMMAND_A_NOT_IMPLEMENTED, HE, 'הפקודה %0 אינה מוטמעת באופן חלקי בתכנה.', ND)
    t(THESIS_EQS_NON_DENIED, HE, 'משוואות התיזה (אלה שלא לוקחים בחשון את השלילה):', ND)
    t(THESIS_EQ_DENIED, HE, 'משוואת הטענה המביאה לסתירה:', ND)
    t(DUMMY_VAR_NEG, HE, 'משתנה דמי כדי לבטא שלילה' , ND)
    t(STATEMENT_A_NOT_FULLY_IMPLEMENTED, HE, 'הטענה %0 אינה מוטמעת באופן מלא במחשב.', ND)
    t(STATEMENT_A_NOT_IMPLEMENTED, HE, 'הטענה %0 אינה מוטמעת בתכנה.', ND)
    t(WLOG_COORDINATES, HE, 'בלי הגבלת הכלליות, ניתן לקבוע חלק מהקואורדינטות:', ND)
    t(CANNOT_DECIDE_ALGEBRAIC_DIFFICULTIES, HE, 'מצטערים, התוכנה לא יכולה להחליט בשל קשיים אלגבריים.', ND)
    t(WEAKENING_TRUE, HE, 'גירסה חלשה יותר של הטענה היא נכונה.', ND)
    t(STATEMENT_TRUE_NDG, HE, 'הטענה יכולה להיות נחשבת אמיתית תחת תנאים של אי-נוון מסוימים:', ND)
    t(AFTER_SUBS, HE, 'לאחר הצבות:', ND)
    t(STATEMENT_TRUE_NDG_UNREADABLE, HE, 'הטענה אמיתית בתנאים מסוימים של אי-ניוון (אין להם ביטוי במונחים גיאומטריים פשוטים):', ND)
    t(ALL_HYPOS_NEG_THESIS, HE, 'ההנחות ושלילת הטענה, אחרי הצבות:', ND)
    t(NOW_CONSIDER, HE, 'כעת מתייחסים למשוואה הבאה:', ND)
    t(CONTRADICTION_THIS_PROVES, HE, 'סתירה! זה מוכיח את הטענה המקורית.', ND)
    t(DIFFICULTY_A, HE,'מצרפים לטענה פולינום ממעלה %0.', ND)
    t(PROOF_PREPARATION_SEEMS_DIFFICULT, HE, 'הכנת ההוכחה נראית מסובכת מדי, מצטערים.', ND)
    t(FORCING_NON_COLLINEARITY, HE, 'לחייב אי-קולינאריות', ND)
    t(THESIS_A_IN_ALGEBRAIC_FORM, HE, 'טענה %0, בצורה אלגברית', ND)
    t(ONLY_FIRST_FIXED_EXPRESSION, HE, 'רק הנקודה החופשית הראשונה יכולה להיות קבועה, מאחר שהטענה היא ביטוי אלגברי.', ND)
    t(A_VALUE_OF_CENTER_OF_B, HE, '%0 הוא שיעור של מרכז ה-%1', ND)
    t(A_VALUE_OF_A_POINT_OF_B, HE, '%0 הוא שיעור של נקודה ב-%1', ND)
    t(A_VALUE_OF_AN_IMPLICITLY_INTRODUCED_SECOND_POINT_FOR_ORTHOGONAL_LINE_AT_B_TO_C, HE, '%0 הוא שיעור של הנקודה השניה על הישר מאונך ב %1 ל %2 (נכנס בצורה סתומה)', ND)
    t(A_VALUE_OF_MIDPOINT_OF_B, HE, '%0 הוא שיעור של נקודת האמצע של %1', ND)
    t(A_VALUE_OF_ROTATION_OF_POINT_B_AROUND_THE_MIDPOINT_OF_C_BY_D_DEGREES, HE, '%0 הוא שיעור של התמונה של הנקודה %1 בסיבוב שמרכזו באמצע של %2 עם זוית %3 מעלות',ND)
    t(VARIABLE_A_IS_ALREADY_DEFINED_PLEASE_REMOVE_IT_FIRST, HE, 'המשתנה %0 כבר הוגדר. נא להסיר אותו.', ND)
    t(PLEASE_OPEN_THE_CAS_VIEW_FIRST, HE, 'נא לפתוח תחילה את תצוגת החישוב האלגברי', ND)
    #
    t(SHOWPROOF, AR, 'أظهرالدليل', HK)
    t(SHOWPROOF_SYNTAX, AR, '[ <تعبير منطقي> ]', HK)
    t(PROVE_THAT_A, AR, 'أثبت أن %0', HK)
    t(LET_A_BE_ARBITRARY_POINTS, AR, 'دع %0 تكون نقاطًا عشوائيه', HK)
    t(LET_A_BE_THE_B, AR, 'دع %0 يكون ال %1', HK)
    t(LET_A_BE_A_B, AR, 'دع %0 يكون %1', HK)
    t(LET_A_BE_THE_REGULAR_POLYGON_BCD, AR, 'اجعل %0 هو %3 مضلع منتظم فوق القطعة المستقيمة %1، %2', HK)
    t(LET_A_BE_THE_REGULAR_BGON_VERTICES_C, AR, 'دع %0 تكون %1مضلع منتظم من رؤوس %2', HK)
    t(DENOTE_THE_EXPRESSION_A_BY_B, AR, 'Denote the expression %0 by %1.', HK)
    t(PROOF_UNKNOWN, AR, 'لا يمكن إثبات هذه العبارة أو نفيها', HK)
    t(STATEMENT_ALWAYS_TRUE, AR, 'العبارة صحيحة دائما', HK)
    t(TRUE_ON_PARTS, AR, 'العبارة صحيحة في بعض الأجزاء، وخاطئه في بعض الأجزاء', HK)
    t(TRUE_UNDER_NONDEGENERACY_CONDITIONS, AR, 'العبارة صحيحة في ظل بعض الظروف غير الانحطاطية (انظر أدناه)', HK)
    t(STATEMENT_FALSE, AR, 'العبارة غير صحيحة', HK)
    t(STATEMENT_TRIVIAL, AR, 'العبارة بديهيه', HK)
    t(PROVE_BY_CONTRADICTION, AR, 'علينا أن نثبت ذلك من خلال التناقض', HK)
    t(NO_FULL_PROOF, AR, 'في الوقت الحالي، لا يمكن تقديم إثبات كامل، ولكن فقط بعض الخطوات', HK)
    t(NO_FULL_PRESENTATION, AR, 'في الخلفية، يتم التحقق من جميع الخطوات، ولكن لم يتم تنفيذ العرض الكامل بعد', HK)
    t(TRY_NEWER_VERSION, AR, 'إن أمكن يرجى تجربة إصدار أحدث من جوجبرة ديسكفري', HK)
    t(UNSUPPORTED_AXES_FIXED_SLOPE_LINES, AR, 'البيانات التي تحتوي على محاور أو خطوط انحدار ثابتة غير مدعوم', HK)
    t(CONSIDERING_DEFINITION_A, AR, 'مع الأخذ في الاعتبار التعريف %0', HK)
    t(LET_FREE_POINT_A_DENOTED_BY_B, AR, 'دع النقطة الحرة %0 يُشار إليها بـ %1', HK)
    t(ONLY_FIRST_FIXED_BECAUSE_A_ON_B, AR, 'يمكن إصلاح النقطة الحرة الأولى فقط، لأن %0 يقع على المسار الخطي %1', HK)
    t(LET_DEPENDENT_POINT_A_DENOTED_BY_B, AR, 'دع النقطة التابعة %0 يُشار إليها بـ %1', HK)
    t(OBJECT_A_INTRODUCES, AR, 'يقدم الكائن %0 المتغيرات الإضافية التالية:', HK)
    t(COMMAND_A_NOT_FULLY_IMPLEMENTED, AR, 'لم يتم تنفيذ الأمر %0 بشكل كامل في المُعامل', HK)
    t(COMMAND_A_NOT_IMPLEMENTED, AR, 'لم يتم تنفيذ الأمر %0 في المبرهنة', HK)
    t(THESIS_EQS_NON_DENIED, AR, 'معادلات الأطروحة (غير المرفوضة):', HK)
    t(THESIS_EQ_DENIED, AR, 'اختزال الأطروحة إلى العبث (بيان مرفوض):', HK)
    t(DUMMY_VAR_NEG, AR, 'متغير وهمي للتعبير عن النفي', HK)
    t(STATEMENT_A_NOT_FULLY_IMPLEMENTED, AR, 'لم يتم تنفيذ البيان %0 بشكل كامل في المُعامل', HK)
    t(STATEMENT_A_NOT_IMPLEMENTED, AR, 'لم يتم تنفيذ البيان %0 في المُعامل', HK)
    t(WLOG_COORDINATES, AR, 'دون فقدان العمومية، يمكن إصلاح بعض الإحداثيات:', HK)
    t(CANNOT_DECIDE_ALGEBRAIC_DIFFICULTIES, AR, 'عذرًا، لا يمكن للبرنامج أن يقرر بسبب الصعوبات الجبرية', HK)
    t(WEAKENING_TRUE, AR, 'تضعيف البيان صحيح', HK)
    t(STATEMENT_TRUE_NDG, AR, 'يمكن الشك في صحة العبارة في ظل بعض الظروف غير الانحطاطية:', HK)
    t(AFTER_SUBS, AR, 'بعد الاستبدال:', HK)
    t(STATEMENT_TRUE_NDG_UNREADABLE, AR, 'العبارة صحيحة في ظل بعض الظروف غير الانحطاطية (لا يمكن التعبير عنها بمصطلحات هندسية بسيطة):', HK)
    t(ALL_HYPOS_NEG_THESIS, AR, 'جميع الفرضيات والأطروحة النافية بعد الاستبدالات:', HK)
    t(NOW_CONSIDER, AR, 'الآن نعتبر المعادلة التالية:', HK)
    t(CONTRADICTION_THIS_PROVES, AR, 'تناقض! وهذا يثبت البيان الأساسي', HK)
    t(DIFFICULTY_A, AR, 'البيان لديه صعوبة %0 درجة', HK)
    t(PROOF_PREPARATION_SEEMS_DIFFICULT, AR, 'يبدو أن إعداد الدليل صعب للغاية من الناحية الحسابية، آسف', HK)
    t(FORCING_NON_COLLINEARITY, AR, 'فرض عدم الخطية المتداخلة لنقاط ثلاثية معينة:', HK)
    t(THESIS_A_IN_ALGEBRAIC_FORM, AR, 'بيان: %0، في الصورة الجبرية:', HK)
    t(ONLY_FIRST_FIXED_EXPRESSION, AR, 'يمكن إصلاح النقطة الحرة الأولى فقط، لأن الأطروحة عبارة عن تعبير', HK)
    t(A_VALUE_OF_CENTER_OF_B, AR, 'قيمة %0 لمركز %1', HK)
    t(A_VALUE_OF_A_POINT_OF_B, AR, 'قيمة %0 للنقطة %1', HK)
    t(A_VALUE_OF_AN_IMPLICITLY_INTRODUCED_SECOND_POINT_FOR_ORTHOGONAL_LINE_AT_B_TO_C, AR, 'ققيمة %0 للنقطة الثانية المقدمة ضمنيًا للخط المتعامد عند %1 إلى %2', HK)
    t(A_VALUE_OF_MIDPOINT_OF_B, AR, 'قيمة %0 لنقطة المنتصف %1', HK)
    t(A_VALUE_OF_ROTATION_OF_POINT_B_AROUND_THE_MIDPOINT_OF_C_BY_D_DEGREES, AR, 'قيمة %0 لدوران النقطة %1 حول نقطة منتصف %2 بمقدار %3 درجة', HK)
    t(VARIABLE_A_IS_ALREADY_DEFINED_PLEASE_REMOVE_IT_FIRST, AR, 'تم تعريف المتغير %0 بالفعل. يرجى إزالته أولا', HK)
    t(PLEASE_OPEN_THE_CAS_VIEW_FIRST, AR, 'يرجى فتح عرض CAS أولاً', HK)
    #
    t(SHOWPROOF, TRK, 'İspatıGöster', SG)
    t(SHOWPROOF_SYNTAX, TRK, '[ <Boole İfadeleri> ]', SG)
    t(PROVE_THAT_A, TRK, '%0 olduğunu ispatlayınız.', SG)
    t(LET_A_BE_ARBITRARY_POINTS, TRK, '%0 ayrık noktalar olsun.', SG)
    t(LET_A_BE_THE_B, TRK, '%0, %1 olsun.', SG)
    t(LET_A_BE_A_B, TRK, '%0, bir %1 olsun.', SG)
    t(LET_A_BE_THE_REGULAR_POLYGON_BCD, TRK, '%0, %1 ve %2 doğru parçalarından geçen düzgün bir %3-gon olsun.', SG)
    t(LET_A_BE_THE_REGULAR_BGON_VERTICES_C, TRK, '%0, köşeleri %2 olan düzgün bir %1-gon olsun.', SG)
    t(DENOTE_THE_EXPRESSION_A_BY_B, TRK, '%0 ifadesini %1 ile gösteriniz.', SG)
    t(PROOF_UNKNOWN, TRK, 'İfade kanıtlanamadı ve çürütülemedi.', SG)
    t(STATEMENT_ALWAYS_TRUE, TRK, 'İfade her zaman doğrudur.', SG)
    t(TRUE_ON_PARTS, TRK, 'İfade bazen doğru bazen yanlıştır.', SG)
    t(TRUE_UNDER_NONDEGENERACY_CONDITIONS, TRK, 'İfade bazı dejenere olmayan koşullar altında doğrudur (Aşağıya bakınız).', SG)
    t(STATEMENT_FALSE, TRK, 'İfade doğrudur.', SG)
    t(STATEMENT_TRIVIAL, TRK, 'İfade önemsizdir.', SG)
    t(PROVE_BY_CONTRADICTION, TRK, 'Çelişki bulma yöntemiyle kanıtlandı.', SG)
    t(NO_FULL_PROOF, TRK, 'Şu anda eksiksiz kanıt sağlanamadı, ancak birkaç adımı kanıtlandı.', SG)
    t(NO_FULL_PRESENTATION, TRK, 'Tüm adımlar arka planda kontrol edildi ancak tam versiyonu henüz uygulanamaz.', SG)
    t(TRY_NEWER_VERSION, TRK, 'GeoGebra Discovery\'nin daha yeni bir sürümünü deneyiniz.', SG)
    t(UNSUPPORTED_AXES_FIXED_SLOPE_LINES, TRK, 'Eksenleri veya sabit eğim çizgilerini içeren ifadeler desteklenmez.', SG)
    t(CONSIDERING_DEFINITION_A, TRK, '%0 tanımı düşünüldüğünde:', SG)
    t(LET_FREE_POINT_A_DENOTED_BY_B, TRK, '%0 serbest noktası %1 ile gösterilsin.', SG)
    t(ONLY_FIRST_FIXED_BECAUSE_A_ON_B, TRK, '%0, %1 ile doğrusal olduğu için yalnızca ilk serbest nokta sabitlenebilir.', SG)
    t(LET_DEPENDENT_POINT_A_DENOTED_BY_B, TRK, '%0 bağımlı noktası %1 ile gösterilsin.', SG)
    t(OBJECT_A_INTRODUCES, TRK, '%0 nesnesi aşağıda yer alan ekstra değişkenleri sunar:', SG)
    t(COMMAND_A_NOT_FULLY_IMPLEMENTED, TRK, '%0 komutu kanıtlama sürecinde tam olarak uygulanamadı.', SG)
    t(COMMAND_A_NOT_IMPLEMENTED, TRK, '%0 komutu kanıtlama sürecinde uygulanamadı.', SG)
    t(THESIS_EQS_NON_DENIED, TRK, 'Önerme denklemleri (reddedilmeyenler):', SG)
    t(THESIS_EQ_DENIED, TRK, 'Olmayan ergi yöntemiyle kanıtlandı (reddedilen ifadeler):', SG)
    t(DUMMY_VAR_NEG, TRK, 'Olumsuzlamayı ifade eden hatalı kukla değişkenler', SG)
    t(STATEMENT_A_NOT_FULLY_IMPLEMENTED, TRK, '%0 ifadesi kanıtlama sürecinde tam olarak uygulanamadı.', SG)
    t(STATEMENT_A_NOT_IMPLEMENTED, TRK, '%0 ifadesi kanıtlama sürecinde uygulanamadı.', SG)
    t(WLOG_COORDINATES, TRK, 'Genel önerme kaybedilmeden bazı koordinatlar sabitlenebilir:', SG)
    t(CANNOT_DECIDE_ALGEBRAIC_DIFFICULTIES, TRK, 'Üzgünüz, cebirsel zorluklardan dolayı program karar veremiyor.', SG)
    t(WEAKENING_TRUE, TRK, 'İfadenin zayıflaması doğrudur.', SG)
    t(STATEMENT_TRUE_NDG, TRK, 'İfadenin bazı dejenere olmayan koşullar altında doğru olduğu düşünülebilir:', SG)
    t(AFTER_SUBS, TRK, 'Yerine koyma işleminden sonra:', SG)
    t(STATEMENT_TRUE_NDG_UNREADABLE, TRK, 'İfade bazı dejenere olmayan koşullar altında doğrudur (basit geometrik terimlerle ifade edilemez):', SG)
    t(ALL_HYPOS_NEG_THESIS, TRK, 'Yerine koyma işleminden sonra tüm hipotezler ve çürütülen önerme:', SG)
    t(NOW_CONSIDER, TRK, 'Şimdi aşağıdaki denklemleri ele alalım:', SG)
    t(CONTRADICTION_THIS_PROVES, TRK, 'Çelişki! Bu esas ifadeyi kanıtlar.', SG)
    t(DIFFICULTY_A, TRK, 'İfadenin %0 derecesinde zorluğu var.', SG)
    t(PROOF_PREPARATION_SEEMS_DIFFICULT, TRK, 'Kanıtın hazırlanması hesaplama açısından çok zor görünüyor, üzgünüz.', SG)
    t(FORCING_NON_COLLINEARITY, TRK, 'Belirli üç noktanın doğrusal olmamasını zorlama:', SG)
    t(THESIS_A_IN_ALGEBRAIC_FORM, TRK, 'Önerme: %0, cebirsel gösterimde:', SG)
    t(STATEMENT_REQUIRES_CONDITIONS, TR, 'İfade bazı koşulları gerektirir:', SG)
    t(ONLY_FIRST_FIXED_EXPRESSION, TRK, 'Önerme bir ifade olduğundan yalnızca ilk serbest nokta sabitlenebilir.', SG)
    t(A_VALUE_OF_CENTER_OF_B, TRK, '%1 merkezinin %0 değeri', SG)
    t(A_VALUE_OF_A_POINT_OF_B, TRK, '%1 noktasının %0 değeri', SG)
    t(A_VALUE_OF_AN_IMPLICITLY_INTRODUCED_SECOND_POINT_FOR_ORTHOGONAL_LINE_AT_B_TO_C, TRK, '%1 ile %2 arasındaki ortogonal çizgi için doğrudan tanımlanan ikinci noktanın %0 değeri', SG)
    t(A_VALUE_OF_MIDPOINT_OF_B, TRK, '%1\'in orta noktasının %0 değeri', SG)
    t(A_VALUE_OF_ROTATION_OF_POINT_B_AROUND_THE_MIDPOINT_OF_C_BY_D_DEGREES, TRK, '%1 noktasının %2 orta noktası etrafında %3 derece dönmesinin %0 değeri', SG)
    t(VARIABLE_A_IS_ALREADY_DEFINED_PLEASE_REMOVE_IT_FIRST, TRK, '%0 değişkeni önceden tanımlanmıştır. İlk olarak bunu siliniz.', SG)
    t(PLEASE_OPEN_THE_CAS_VIEW_FIRST, TRK, 'İlk olarak CAS görünümünü açınız.', SG)
    #
    t(SHOWPROOF, IT, 'MostraDimostrazione', SR)
    t(SHOWPROOF_SYNTAX, IT, '[ <Espressione booleana> ]', SR)
    t(PROVE_THAT_A, IT, 'Dimostra che %0.', SR)
    t(LET_A_BE_ARBITRARY_POINTS, IT, 'Siano %0 punti arbitrari.', SR)
    t(LET_A_BE_THE_B, IT, 'Sia %0 il/la %1.', SR)
    t(LET_A_BE_A_B, IT, 'Sia %0 un/una %1.', SR)
    t(LET_A_BE_THE_REGULAR_POLYGON_BCD, IT, 'Sia %0 il %3-gono regolare costruito sul segmento %1, %2.', SR)
    t(LET_A_BE_THE_REGULAR_BGON_VERTICES_C, IT, 'Sia %0 il %1-gono regolare di vertici %2.', SR)
    t(DENOTE_THE_EXPRESSION_A_BY_B, IT, 'Indica l\'espressione %0 come %1.', SR)
    t(PROOF_UNKNOWN, IT, 'Questa proposizione non ha un valore di verità certo.', SR)
    t(STATEMENT_ALWAYS_TRUE, IT, 'Questa proposizione è sempre vera.', SR)
    t(TRUE_ON_PARTS, IT, 'Questa proposizione è parzialmente vera e parzialmente falsa.', SR)
    t(TRUE_UNDER_NONDEGENERACY_CONDITIONS, IT, 'Questa proposizione è vera per casi non degeneri (vedere di seguito).', SR)
    t(STATEMENT_FALSE, IT, 'Questa proposizione è falsa.', SR)
    t(STATEMENT_TRIVIAL, IT, 'Questa proposizione è banale.', SR)
    t(PROVE_BY_CONTRADICTION, IT, 'Possiamo dimostrare ciò per contraddizione.', SR)
    t(NO_FULL_PROOF, IT, 'Al momento non è disponibile una dimostrazione completa, ma solo alcuni passi.', SR)
    t(NO_FULL_PRESENTATION, IT, 'Tutti i passi sono verificati, ma non è ancora stata implementata una presentazione completa.', SR)
    t(TRY_NEWER_VERSION, IT, 'Per favore prova se possibile una nuova versione di GeoGebra Discovery.', SR)
    t(UNSUPPORTED_AXES_FIXED_SLOPE_LINES, IT, 'Le proposizioni che contengono assi o rette con coefficiente angolare costante non sono supportate.', SR)
    t(CONSIDERING_DEFINITION_A, IT, 'Si consideri la definizione %0:', SR)
    t(LET_FREE_POINT_A_DENOTED_BY_B, IT, 'Sia il punto libero %0 indicato da %1.', SR)
    t(ONLY_FIRST_FIXED_BECAUSE_A_ON_B, IT, 'Solo il primo punto libero può essere fissato, perchè %0 è sul percorso lineare %1.', SR)
    t(LET_DEPENDENT_POINT_A_DENOTED_BY_B, IT, 'Sia il punto dipendente %0 indicato da %1.', SR)
    t(OBJECT_A_INTRODUCES, IT, 'L\'oggetto %0 introduce le seguenti ulteriori variabili:', SR)
    t(COMMAND_A_NOT_FULLY_IMPLEMENTED, IT, 'Il comando %0 non è implementato completamente.', SR)
    t(COMMAND_A_NOT_IMPLEMENTED, IT, 'Il comando %0 non è implementato.', SR)
    t(THESIS_EQS_NON_DENIED, IT, 'Equazioni della tesi (non-negate):', SR)
    t(THESIS_EQ_DENIED, IT, 'Tesi per assurdo (negazione della tesi):', SR)
    t(DUMMY_VAR_NEG, IT, 'variabile ausiliaria che esprime la negazione', SR)
    t(STATEMENT_A_NOT_FULLY_IMPLEMENTED, IT, 'La proposizione %0 non è implementata completamente.', SR)
    t(STATEMENT_A_NOT_IMPLEMENTED, IT, 'La proposizione %0 non è implementata.', SR)
    t(WLOG_COORDINATES, IT, 'Senza perdita di generalità, alcune coordinate possono essere fissate:', SR)
    t(CANNOT_DECIDE_ALGEBRAIC_DIFFICULTIES, IT, 'Spiacente, il programma non può arrivare a una decisione a causa di difficoltà di tipo algebrico.', SR)
    t(WEAKENING_TRUE, IT, 'Una versione debole di questa proposizione è vera.', SR)
    t(STATEMENT_TRUE_NDG, IT, 'Questa proposizione potrebbe essere vera per casi non degeneri:', SR)
    t(AFTER_SUBS, IT, 'Dopo le sostituzioni:', SR)
    t(STATEMENT_TRUE_NDG_UNREADABLE, IT, 'Questa proposizione è vera per casi non degeneri (che non possonon essere espressi in termini geometrici semplici):', SR)
    t(ALL_HYPOS_NEG_THESIS, IT, 'Tutte le ipotesi e la negazione della tesi dopo le sostituzioni:', SR)
    t(NOW_CONSIDER, IT, 'Consideriamo ora la seguente equazione:', SR)
    t(CONTRADICTION_THIS_PROVES, IT, 'Contraddizione! Ciò dimostra la proposizione originale.', SR)
    t(DIFFICULTY_A, IT, 'Questa proposizione ha una complessità di ordine %0.', SR)
    t(PROOF_PREPARATION_SEEMS_DIFFICULT, IT, 'Spiacenti, la preparazione della dimostrazione presenta difficoltà di tipo computazionale.', SR)
    t(FORCING_NON_COLLINEARITY, IT, 'Forzando la non collinearità per certe terne di punti:', SR)
    t(THESIS_A_IN_ALGEBRAIC_FORM, IT, 'Tesi: %0, in forma algebrica:', SR)
    t(ONLY_FIRST_FIXED_EXPRESSION, IT, 'Solo il primo punto libero può essere fissato, perchè la tesi è un\'espressione.', SR)
    t(A_VALUE_OF_CENTER_OF_B, IT, 'valore %0 del centro di %1', SR)
    t(A_VALUE_OF_A_POINT_OF_B, IT, 'valore %0 di un punto di %1', SR)
    t(A_VALUE_OF_AN_IMPLICITLY_INTRODUCED_SECOND_POINT_FOR_ORTHOGONAL_LINE_AT_B_TO_C, IT, 'valore %0 di un secondo punto introdotto implicitamente per la retta %1 ortogonale a %2', SR)
    t(A_VALUE_OF_MIDPOINT_OF_B, IT, 'valore %0 del punto medio di %1', SR)
    t(A_VALUE_OF_ROTATION_OF_POINT_B_AROUND_THE_MIDPOINT_OF_C_BY_D_DEGREES, IT, 'valore %0 della rotazione del punto %1 di %3 gradi attorno al punto medio di %2', SR)
    t(VARIABLE_A_IS_ALREADY_DEFINED_PLEASE_REMOVE_IT_FIRST, IT, 'La variable %0 è già definita. È necessario rimuoverla.', SR)
    t(PLEASE_OPEN_THE_CAS_VIEW_FIRST, IT, 'Aprire la vista CAS prima di procedere.', SR)

    c(REALQUANTIFIERELIMINATION, 'RealQuantifierElimination')
    c(REALQUANTIFIERELIMINATION_SYNTAX, 'RealQuantifierElimination.Syntax')
    t(REALQUANTIFIERELIMINATION, EN, 'RealQuantifierElimination', ZK)
    t(REALQUANTIFIERELIMINATION, DE, 'ReelleQuantorenelimination', ZK)
    t(REALQUANTIFIERELIMINATION, ES, 'REC', ZK)
    t(REALQUANTIFIERELIMINATION, HU, 'ValósKvantorelimináció', ZK)
    t(REALQUANTIFIERELIMINATION_SYNTAX, EN, '[ <Expression> ]', ZK)
    t(REALQUANTIFIERELIMINATION_SYNTAX, DE, '[ <Ausdruck> ]', ZK)
    t(REALQUANTIFIERELIMINATION_SYNTAX, ES, '[ <Expresión> ]', ZK)
    t(REALQUANTIFIERELIMINATION_SYNTAX, HU, '[ <Kifejezés> ]', ZK)

    c(STEPWISEDISCOVERY, 'StepwiseDiscovery')
    c(STEPWISEDISCOVERY_SYNTAX, 'StepwiseDiscovery.Syntax')
    t(STEPWISEDISCOVERY, EN, 'StepwiseDiscovery', ZK)
    t(STEPWISEDISCOVERY, DE, 'SchrittweisesEntdecken', ZK)
    t(STEPWISEDISCOVERY, HU, 'FelfedezésLépésenként', ZK)
    t(STEPWISEDISCOVERY, ES, 'DescubrimientoProgresivo', ZK)
    t(STEPWISEDISCOVERY_SYNTAX, EN, "[ ]\n[ <Boolean> ]", ZK)
    t(STEPWISEDISCOVERY_SYNTAX, DE, "[ ]\n[ <Wahrheitswert> ]", ZK)
    t(STEPWISEDISCOVERY_SYNTAX, HU, "[ ]\n[ <Logikai érték> ]", ZK)
    t(STEPWISEDISCOVERY_SYNTAX, ES, "[ ]\n[ <Valor lógico> ]", ZK)
    m(STEPWISEDISCOVERY_INFORMATION, 'Information')
    t(STEPWISEDISCOVERY_INFORMATION, EN, 'Information', ZK)
    t(STEPWISEDISCOVERY_INFORMATION, DE, 'Information', ZK)
    t(STEPWISEDISCOVERY_INFORMATION, HU, 'Információ', ZK)
    t(STEPWISEDISCOVERY_INFORMATION, ES, 'Información', ZK)
    m(STEPWISEDISCOVERY_ENABLED, 'StepwiseDiscoveryEnabled')
    t(STEPWISEDISCOVERY_ENABLED, EN, 'The stepwise discovery mode is enabled.', ZK)
    t(STEPWISEDISCOVERY_ENABLED, DE, 'Schrittweises Entdecken ist eingeschaltet.', ZK)
    t(STEPWISEDISCOVERY_ENABLED, HU, 'A lépésenkénti felfedezés mód bekapcsolva.', ZK)
    t(STEPWISEDISCOVERY_ENABLED, ES, 'El descubrimiento progresivo está activada.', ZK)
    m(STEPWISEDISCOVERY_DISABLED, 'StepwiseDiscoveryDisabled')
    t(STEPWISEDISCOVERY_DISABLED, EN, 'The stepwise discovery mode is disabled.', ZK)
    t(STEPWISEDISCOVERY_DISABLED, DE, 'Schrittweises Entdecken ist ausgeschaltet.', ZK)
    t(STEPWISEDISCOVERY_DISABLED, HU, 'A lépésenkénti felfedezés mód kikapcsolva.', ZK)
    t(STEPWISEDISCOVERY_DISABLED, ES, 'El descubrimiento progresivo está desactivada.', ZK)
    m(STEPWISEDISCOVERY_STYLEBAR, 'stylebar.Discover')
    t(STEPWISEDISCOVERY_STYLEBAR, EN, 'Switch stepwise discovery on or off', ZK)
    t(STEPWISEDISCOVERY_STYLEBAR, DE, 'Schrittweises Entdecken ein- oder ausschalten', ZK)
    t(STEPWISEDISCOVERY_STYLEBAR, HU, 'Lépésenkénti felfedezés mód be- vagy kikapcsolása', ZK)
    t(STEPWISEDISCOVERY_STYLEBAR, ES, 'Activa o desactiva el descubrimiento progresivo', ZK)

    m(EXPORT_AS_LATEX, 'ExportAsLaTeX')
    m(CAS_MAPLE_TO_CLIPBOARD, 'CASMapleToClipboard')
    m(CAS_MATHEMATICA_TO_CLIPBOARD,'CASMathematicaToClipboard')
    m(CAS_GIAC_TO_CLIPBOARD, 'CASGiacToClipboard')
    m(CLEAR_CAS_VIEW, 'ClearCASView')
    m(EXPORT_CAS_MAPLE, 'ExportCASMaple')
    m(EXPORT_CAS_HTML, 'ExportCASHtml')
    m(EXPORT_CAS_LATEX, 'ExportCASLatex')
    m(EXPORT_CAS_MATHEMATICA, 'ExportCASMathematica')
    m(EXPORT_CAS_GIAC, 'ExportCASGiac')
    t(EXPORT_AS_LATEX, EN, 'Export as LaTeX', ZK)
    t(EXPORT_AS_LATEX, DE, 'Export als LaTeX', ZK)
    t(EXPORT_AS_LATEX, HU, 'Exportálás LaTeX-ként', ZK)
    t(EXPORT_AS_LATEX, ES, 'Exportar como LaTeX', ZK)
    t(CAS_MAPLE_TO_CLIPBOARD, EN, 'CAS View as Maple to Clipboard', ZK)
    t(CAS_MAPLE_TO_CLIPBOARD, HU, 'CAS ablak Maple formátumban a vágólapra', ZK)
    t(CAS_MATHEMATICA_TO_CLIPBOARD, EN, 'CAS View as Mathematica to Clipboard', ZK)
    t(CAS_MATHEMATICA_TO_CLIPBOARD, HU, 'CAS ablak Mathematica formátumban a vágólapra', ZK)
    t(CAS_GIAC_TO_CLIPBOARD, EN, 'CAS View as Giac to Clipboard', ZK)
    t(CAS_GIAC_TO_CLIPBOARD, HU, 'CAS ablak Giac formátumban a vágólapra', ZK)
    t(CLEAR_CAS_VIEW, EN, 'Clear CAS View', ZK)
    t(CLEAR_CAS_VIEW, HU, 'CAS ablak törlése', ZK)
    t(EXPORT_CAS_MAPLE, EN, 'Export CAS View to Maple', ZK)
    t(EXPORT_CAS_MAPLE, HU, 'CAS ablak export Maple-be', ZK)
    t(EXPORT_CAS_HTML, EN, 'Export CAS View to HTML', ZK)
    t(EXPORT_CAS_HTML, HU, 'CAS ablak export HTML-be', ZK)
    t(EXPORT_CAS_LATEX, EN, 'Export CAS View to LaTeX', ZK)
    t(EXPORT_CAS_LATEX, HU, 'CAS ablak export LaTeX-be', ZK)
    t(EXPORT_CAS_MATHEMATICA, EN, 'Export CAS View to Mathematica', ZK)
    t(EXPORT_CAS_MATHEMATICA, HU, 'CAS ablak export Mathematicába', ZK)
    t(EXPORT_CAS_GIAC, EN, 'Export CAS View to Giac', ZK)
    t(EXPORT_CAS_GIAC, HU, 'CAS ablak export Giac-ba', ZK)

    c(PLOT2D, 'Plot2D')
    c(PLOT2D_SYNTAX, 'Plot2D.Syntax')
    t(PLOT2D, EN, 'Plot2D', ZK)
    t(PLOT2D, DE, 'Zeichne2D', ZK)
    t(PLOT2D, ES, 'Grafica2D', ZK)
    t(PLOT2D, HU, 'Rajzol2D', ZK)
    t(PLOT2D_SYNTAX, EN, '[ <Function> ]', ZK)
    t(PLOT2D_SYNTAX, DE, '[ <Funktion> ]', ZK)
    t(PLOT2D_SYNTAX, ES, '[ <Función> ]', ZK)
    t(PLOT2D_SYNTAX, HU, '[ <Függvény> ]', ZK)
